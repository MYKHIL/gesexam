<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GES Promotion Exam Quiz - Management System</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-T8K659BSH3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-T8K659BSH3');
    </script>

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
            min-height: 100vh;
            /* Ensure full viewport height */
        }

        .option-button {
            display: flex;
            align-items: flex-start;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            background-color: #ffffff;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            width: 100%;
        }

        .option-button:hover:not(:disabled) {
            border-color: #3b82f6;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }

        .option-button.selected {
            background-color: #dbeafe;
            border-color: #3b82f6;
        }

        .option-button.correct {
            background-color: #d1fae5 !important;
            border-color: #10b981 !important;
            font-weight: 600;
        }

        .option-button.incorrect {
            background-color: #fee2e2 !important;
            border-color: #ef4444 !important;
            font-weight: 600;
        }

        .option-letter {
            font-weight: 700;
            width: 2rem;
            flex-shrink: 0;
            margin-right: 0.5rem;
            color: #4b5563;
        }

        .question-nav-button {
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.2s;
            cursor: pointer;
        }

        .nav-current {
            background-color: #3b82f6;
            color: white;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.5);
        }

        .nav-answered {
            background-color: #10b981;
            color: white;
        }

        .nav-unanswered {
            background-color: #e5e7eb;
            color: #4b5563;
        }

        /* CRITICAL: Ensure horizontal scrolling is contained within the nav area */
        .grid-container {
            overflow-x: auto;
            white-space: nowrap;
            /* Use padding for internal spacing rather than margin to prevent overflow */
            padding-bottom: 0.5rem;
        }

        /* Custom file input styling */
        .custom-file-input {
            border: 2px dashed #9ca3af;
            padding: 1rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .custom-file-input:hover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }

        .file-list {
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #4b5563;
        }
    </style>
</head>

<body class="min-h-screen">

    <div id="app" class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-extrabold text-blue-800 tracking-tight">GES Promotion Exam Practice</h1>
            <p id="quiz-title" class="text-gray-600 mt-2">Immediate Feedback Mode</p>
            <div id="online-status-badge" class="mt-2">
                <!-- Will be populated by JS: shows small icon and online count -->
                <span id="online-badge"
                    class="inline-flex items-center px-3 py-1 rounded-full text-lg font-extrabold text-gray-600 bg-gray-100">
                    <svg class="w-4 h-4 mr-2 text-gray-500" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="4" cy="4" r="3" fill="#9CA3AF" />
                    </svg>
                    — online
                </span>
            </div>
        </header>

        <nav class="bg-white p-2 mb-6 rounded-xl shadow-lg flex justify-center space-x-2 sm:space-x-4">
            <button onclick="setView('home')" id="nav-home"
                class="px-3 sm:px-4 py-2 text-sm font-medium rounded-lg transition-colors bg-blue-500 text-white">
                Study
            </button>
            <button onclick="setView('management')" id="nav-management"
                class="px-3 sm:px-4 py-2 text-sm font-medium rounded-lg transition-colors text-gray-700 hover:bg-gray-100">
                Management
            </button>
            <button onclick="setView('settings')" id="nav-settings"
                class="px-3 sm:px-4 py-2 text-sm font-medium rounded-lg transition-colors text-gray-700 hover:bg-gray-100">
                Settings
            </button>
        </nav>

        <main id="content-area" class="bg-white p-6 sm:p-8 rounded-xl shadow-2xl">
            <!-- Dynamic content will be rendered here -->
        </main>

        <!-- Loading Indicator -->
        <div id="loading-indicator"
            class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-8 max-w-md shadow-2xl">
                <div class="flex flex-col items-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
                    <h3 class="text-xl font-bold text-gray-800 mb-2">Loading Questions</h3>
                    <p class="text-gray-600 text-center mb-4" id="loading-status">Scanning for question files...</p>
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div id="loading-progress" class="bg-blue-600 h-2 rounded-full transition-all duration-300"
                            style="width: 0%"></div>
                    </div>
                    <p class="text-sm text-gray-500 mt-4" id="loading-count">0 questions loaded</p>
                    <p class="text-xs text-gray-600 mt-4 text-center">
                        For best compatibility, we recommend opening this app in
                        <a href="https://www.google.com/chrome/" target="_blank" rel="noopener noreferrer"
                            class="text-blue-600 font-semibold hover:underline">Google Chrome</a>.
                        Some browsers may not fully support the built-in reader or file loading behavior.
                    </p>
                </div>
            </div>
        </div>

        <!-- Message Box for Alerts -->
        <div id="message-box"
            class="fixed bottom-4 right-4 p-4 rounded-lg shadow-xl text-white font-semibold transition-all duration-300 transform translate-y-full opacity-0 z-50">
        </div>

        <!-- Developer Contact Footer -->
        <footer class="mt-8 bg-gradient-to-r from-blue-600 to-blue-800 text-white p-6 rounded-xl shadow-lg">
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-6">
                <!-- Developer Info -->
                <div class="text-center sm:text-left">
                    <h3 class="text-lg font-bold mb-2">Developer Contact</h3>
                    <p class="text-blue-100 mb-1"><span class="font-semibold">Name:</span> Mr. Michael Darko</p>
                    <p class="text-blue-100 mb-1"><span class="font-semibold">School:</span> Ayirebi D/A Basic School
                        'B'</p>
                    <p class="text-blue-100 mb-1"><span class="font-semibold">District:</span> Akyemansa</p>
                    <p class="text-blue-100"><span class="font-semibold">Phone:</span> <a href="tel:+233542410613"
                            class="hover:underline">0542410613</a></p>
                </div>
                <!-- Donation Info -->
                <div class="text-center sm:text-left">
                    <h3 class="text-lg font-bold mb-2">Support This Project</h3>
                    <p class="text-blue-100 mb-1">If you find this helpful, please consider donating:</p>
                    <p class="text-blue-100"><span class="font-semibold">Mobile Money:</span> <a
                            href="tel:+233241899862" class="hover:underline font-bold text-yellow-300">0241899862</a>
                    </p>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-blue-400 text-center text-sm text-blue-100">
                <p>© 2025 GES Promotion Exam Practice. Built with passion to help students succeed.</p>
            </div>
        </footer>
    </div>

    <script>
        // --- Global State and Constants ---
        const LOCAL_STORAGE_KEY = 'gesAdiiQuizQuestions';
        const SETTINGS_KEY = 'gesAdiiQuizSettings';
        const SESSION_HISTORY_KEY = 'gesAdiiSessionHistory';
        // JSONBin.io configuration (provided by user)
        const JSONBIN_BIN_ID = '69296a23ae596e708f7617ae';
        const JSONBIN_MASTER_KEY = '$2a$10$Zwr/q5r0c.Lv/6Ikq9a.ROrJruWGsHzf8uSI/HWq7yjG.4OrsE2O6';
        // Admin password to view reported questions (client-side check)
        // NOTE: In production, move admin validation to a server-side endpoint.
        const JSONBIN_ADMIN_PASSWORD = 'admin-password-placeholder';
        // Separate JSONBin for question reviews/reports (per user's request)
        const JSONBIN_REVIEWS_BIN_ID = '692ddf72ae596e708f7cd475';
        // Firebase configuration (primary database)
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyD64PHz4QI-Qjls55BGjkhtLi-Ro0IFxxc",
            authDomain: "ges-promotions-exam.firebaseapp.com",
            projectId: "ges-promotions-exam",
            storageBucket: "ges-promotions-exam.firebasestorage.app",
            messagingSenderId: "466473513288",
            appId: "1:466473513288:web:4106ce050d91783416c37d",
            measurementId: "G-6MYF15GZWE"
        };

        // Toggle user-facing Firebase failure notifications (set to false to suppress)
        const FIREBASE_NOTIFICATION_ENABLED = false;
        // Number of days a score remains eligible for global rankings
        const RANKING_TTL_DAYS = 5;
        // Whether to attempt automatic anonymous Firebase Authentication
        const FIREBASE_AUTO_ANONYMOUS = true;

        // Firestore reference (initialized later)
        let firestoreDb = null;
        let firebaseInitialized = false;

        async function initFirebase() {
            if (firebaseInitialized) return;
            try {
                const { initializeApp } = await import('https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js');
                const { getFirestore, doc, getDoc, setDoc, updateDoc, collection, getDocs, deleteDoc, query, orderBy, limit, onSnapshot, where } = await import('https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js');
                const { getAuth, signInAnonymously, onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js');
                const { getAnalytics } = await import('https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js');

                const app = initializeApp(FIREBASE_CONFIG);
                const auth = getAuth(app);
                firestoreDb = getFirestore(app);

                // Expose commonly used functions via a small shim
                window._fb = { doc, getDoc, setDoc, updateDoc, collection, getDocs, deleteDoc, auth, query, orderBy, limit, onSnapshot, where };

                // Initialize Analytics (best-effort) and attempt anonymous sign-in when configured to do so
                try {
                    if (getAnalytics) {
                        try { getAnalytics(app); } catch (e) { console.debug('getAnalytics failed (non-fatal):', e); }
                    }
                } catch (e) { /* ignore */ }
                if (FIREBASE_AUTO_ANONYMOUS) {
                    try {
                        // signInAnonymously will create a valid auth token required by rules that check request.auth
                        await signInAnonymously(auth);
                        // Wait until auth state is settled
                        await new Promise((resolve) => {
                            const unsub = onAuthStateChanged(auth, (user) => {
                                if (user) {
                                    console.log('Firebase auth ready (uid):', user.uid);
                                } else {
                                    console.log('Firebase auth state change: no user');
                                }
                                unsub();
                                resolve();
                            });
                        });
                    } catch (authErr) {
                        // Build concise details
                        const authCode = authErr && authErr.code ? authErr.code : null;
                        const authMessage = authErr && authErr.message ? authErr.message : String(authErr);
                        const usedCreds = {
                            projectId: FIREBASE_CONFIG && FIREBASE_CONFIG.projectId ? FIREBASE_CONFIG.projectId : null,
                            authDomain: FIREBASE_CONFIG && FIREBASE_CONFIG.authDomain ? FIREBASE_CONFIG.authDomain : null,
                            apiKey: FIREBASE_CONFIG && FIREBASE_CONFIG.apiKey ? FIREBASE_CONFIG.apiKey : null,
                            appId: FIREBASE_CONFIG && FIREBASE_CONFIG.appId ? FIREBASE_CONFIG.appId : null
                        };

                        // Log full details to console for debugging
                        console.error('Firebase anonymous auth failed:', { code: authCode, message: authMessage, usedCreds, fullError: authErr });

                        // Provide an actionable, user-facing hint when possible
                        let hint = '';
                        if (authCode && (authCode.indexOf('operation-not-allowed') !== -1 || authCode.indexOf('operation-not-allowed') !== -1)) {
                            hint = 'Enable Anonymous sign-in in Firebase Console → Authentication → Sign-in method.';
                        } else if (authCode && authCode.indexOf('configuration') !== -1) {
                            hint = 'Check your Firebase project configuration (apiKey, authDomain, projectId, appId) in the app.';
                        }

                        try {
                            if (FIREBASE_NOTIFICATION_ENABLED) {
                                const shortMsg = authCode ? `${authCode}: ${authMessage}` : authMessage;
                                showMessage(`Firebase auth failed: ${shortMsg}. ${hint} See console for details.`, 'error');
                            }
                        } catch (err) { }
                    }
                }

                firebaseInitialized = true;
                console.log('Firebase initialized and Firestore is available');
            } catch (e) {
                console.warn('Could not initialize Firebase (will use jsonbin fallback):', e);
                try { if (FIREBASE_NOTIFICATION_ENABLED) showMessage('Could not initialize Firebase — falling back to jsonbin.io', 'info'); } catch (err) { /* ignore showMessage errors */ }
                firebaseInitialized = false;
            }
        }

        let renderResultsCalled = false;
        let globalUsersCache = {}; // Cache for all users (deviceId -> user object)
        let allQuestions = []; // Master list of all questions (static or uploaded)
        let sessionQuestions = []; // Subset of questions for the current session (based on settings)
        let currentView = 'home';
        let previousView = 'home'; // Track previous view for back navigation
        let currentQuestionIndex = 0;
        let userAnswers = {};
        let currentSelection = null;
        let feedbackShown = false;
        let reviewMode = false; // Flag to track if we're in review mode
        let sessionHistory = []; // Array to store all session scores and timestamps
        let sessionResultsSaved = false; // Flag to prevent duplicate session saves
        let shouldAutoSpeakQuestion = false; // Flag to trigger auto-speak on question render

        // Updated quizSettings with new native TTS options
        let quizSettings = {
            numQuestions: 25,
            randomize: true,
            ttsEnabled: true, // Reader ON by default
            ttsVoice: null, // URI of the selected voice
            ttsRate: 1,     // Playback rate (0.1 to 10)
            ttsRate: 1,     // Playback rate (0.1 to 10)
            ttsPitch: 1,    // Playback pitch (0 to 2)
            timeLimit: 0    // Limit in minutes (0 = disabled)
        };

        let quizTimerInterval = null;
        let sessionEndTime = null;

        const contentArea = document.getElementById('content-area');
        const messageBox = document.getElementById('message-box');
        const quizTitleEl = document.getElementById('quiz-title');
        let voices = []; // To store available system voices

        // --- Utility Functions ---

        function showMessage(message, type = 'success') {
            const baseClass = 'fixed bottom-4 right-4 p-4 rounded-lg shadow-xl font-semibold text-white transition-all duration-300 transform ';
            let styleClass = '';

            if (type === 'success') {
                styleClass = 'bg-green-600';
            } else if (type === 'error') {
                styleClass = 'bg-red-600';
            } else if (type === 'info') {
                styleClass = 'bg-blue-600';
            }

            messageBox.className = baseClass + styleClass + ' translate-y-0 opacity-100';
            messageBox.textContent = message;

            setTimeout(() => {
                messageBox.className = baseClass + styleClass + ' translate-y-full opacity-0';
            }, 3000);
        }

        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return String(unsafe)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // Normalize various timestamp formats (number ms, number seconds, Firestore Timestamp, ISO string)
        function parseTimestampToMs(ts) {
            try {
                if (!ts && ts !== 0) return NaN;
                // Firestore Timestamp object (has seconds & nanoseconds)
                if (typeof ts === 'object' && ts !== null) {
                    if (typeof ts.toDate === 'function') {
                        return ts.toDate().getTime();
                    }
                    if (typeof ts.seconds === 'number') {
                        // seconds -> ms
                        return (ts.seconds * 1000) + (ts.nanoseconds ? Math.floor(ts.nanoseconds / 1000000) : 0);
                    }
                }
                // number: could be seconds or milliseconds
                if (typeof ts === 'number') {
                    // If it's in seconds (reasonable cutoff), convert to ms
                    if (ts < 1e12) return ts * 1000;
                    return ts;
                }
                // string: numeric-only strings are likely seconds or ms
                if (typeof ts === 'string') {
                    const trimmed = ts.trim();
                    if (!trimmed) return NaN;
                    // ISO-like strings parse correctly
                    const isoParse = Date.parse(trimmed);
                    if (!isNaN(isoParse)) return isoParse;
                    // numeric string fallback
                    if (/^\d+$/.test(trimmed)) {
                        const n = Number(trimmed);
                        if (n < 1e12) return n * 1000;
                        return n;
                    }
                    // last-resort: attempt Date constructor
                    const d = new Date(trimmed);
                    return isNaN(d.getTime()) ? NaN : d.getTime();
                }
                return NaN;
            } catch (e) {
                return NaN;
            }
        }

        function normalizeTimestampToISO(ts) {
            const ms = parseTimestampToMs(ts);
            if (isNaN(ms)) return null;
            return new Date(ms).toISOString();
        }

        // Sanitize a user name to a safe Firestore document id (lowercase, alnum and underscores)
        function sanitizeForDocId(name) {
            if (!name) return null;
            return String(name)
                .toLowerCase()
                .normalize('NFKD')
                .replace(/[^a-z0-9]+/g, '_')
                .replace(/^_+|_+$/g, '')
                .replace(/_+/g, '_') || null;
        }

        // --- Global Rankings Filtering Functions ---
        // These centralized functions ensure all parts of the app use the same 5-day filtering rules

        /**
         * Get the cutoff timestamp for global rankings (5 days ago)
         * @returns {number} - Timestamp in milliseconds
         */
        function getGlobalRankingsCutoff() {
            return Date.now() - (RANKING_TTL_DAYS * 24 * 60 * 60 * 1000);
        }

        /**
         * Get the best score for a user within the ranking window (5 days)
         * Checks both latestScore/latestTotal fields and scores array
         * @param {Object} user - User object with scores
         * @param {number} cutoffTs - Cutoff timestamp in milliseconds
         * @returns {Object|null} - Best score object or null if no valid scores
         */
        function getBestScoreWithinWindow(user, cutoffTs) {
            if (!user) return null;
            const candidates = [];

            // Include explicit latest fields if available
            try {
                if (user.latestTotal != null && Number(user.latestTotal) > 0) {
                    // Try to find timestamp for latest score
                    let ts = null;
                    const preferNames = ['latestScoreTimestamp', 'latestTimestamp', 'latestAt', 'latest_time', 'latest_time_ms'];
                    for (const p of preferNames) {
                        if (user[p]) { ts = user[p]; break; }
                    }
                    // If not found, try to correlate with scores array
                    try {
                        if (!ts && Array.isArray(user.scores) && user.scores.length) {
                            for (let i = user.scores.length - 1; i >= 0; i--) {
                                const s = user.scores[i];
                                const total = (s && (s.totalQuestions != null ? s.totalQuestions : (s.total != null ? s.total : 0)));
                                const perc = (s && s.percentage != null) ? parseFloat(s.percentage) : null;
                                if (total && Number(total) > 0 && Number(total) === Number(user.latestTotal)) {
                                    if (perc !== null && user.latestScore != null) {
                                        if (Math.abs(perc - parseFloat(user.latestScore)) < 0.0001) {
                                            ts = s.timestamp || s.time || s.t || null;
                                            break;
                                        }
                                    } else {
                                        ts = s.timestamp || s.time || s.t || null;
                                        break;
                                    }
                                }
                            }
                        }
                    } catch (e) { /* ignore correlation errors */ }
                    // Fallback to lastTimestamp if still unknown
                    if (!ts) ts = user.lastTimestamp || null;
                    candidates.push({
                        percentage: (user.latestScore != null ? parseFloat(user.latestScore) : 0),
                        correct: (user.latestCorrect != null ? user.latestCorrect : 0),
                        total: Number(user.latestTotal),
                        timestamp: ts
                    });
                }
            } catch (e) { /* ignore malformed */ }

            // Include entries from scores array
            if (Array.isArray(user.scores) && user.scores.length) {
                for (const s of user.scores) {
                    try {
                        const total = (s && (s.totalQuestions != null ? s.totalQuestions : (s.total != null ? s.total : 0)));
                        if (!total || Number(total) <= 0) continue;
                        const ts = s.timestamp || s.time || s.t || null;
                        if (!ts) continue;
                        candidates.push({
                            percentage: (s.percentage != null ? parseFloat(s.percentage) : 0),
                            correct: (s.correctAnswers != null ? s.correctAnswers : (s.correct != null ? s.correct : 0)),
                            total: Number(total),
                            timestamp: ts
                        });
                    } catch (e) { /* skip malformed entries */ }
                }
            }

            // Filter by cutoff
            const valid = candidates.map(c => {
                const t = parseTimestampToMs(c.timestamp);
                return isNaN(t) ? null : Object.assign({}, c, { _ts: t });
            }).filter(Boolean).filter(c => c._ts >= cutoffTs);

            if (!valid || valid.length === 0) return null;

            // Pick best by percentage, then total, then newest timestamp
            valid.sort((a, b) => {
                if (b.percentage !== a.percentage) return b.percentage - a.percentage;
                if (b.total !== a.total) return b.total - a.total;
                return b._ts - a._ts;
            });

            const best = valid[0];
            return {
                percentage: best.percentage,
                correct: best.correct,
                total: best.total,
                timestamp: new Date(best._ts).toISOString()
            };
        }

        /**
         * Filter and rank users for global rankings
         * Only includes users with valid scores within the TTL window (5 days)
         * @param {Array} users - Array of user objects
         * @returns {Array} - Ranked array of users with their best scores
         */
        function filterUsersForRankings(users) {
            const cutoff = getGlobalRankingsCutoff();

            // Filter: only include users with valid name and at least one score within window
            const filtered = (users || []).filter(u => {
                if (!u || !u.deviceId || !u.name || String(u.name).trim() === '') return false;
                const best = getBestScoreWithinWindow(u, cutoff);
                if (best === null) {
                    // Debug: Log why a user might be filtered out if they have scores
                    if (u.scores && u.scores.length > 0) {
                        // Uncomment for verbose debugging:
                        // console.debug(`[filterUsersForRankings] Dropping user ${u.name} (Scores: ${u.scores.length}) - No score within window (Cutoff: ${cutoff})`);
                    }
                }
                return best !== null;
            });

            // Map to ranked format with best score
            const ranked = filtered.map(u => {
                const best = getBestScoreWithinWindow(u, cutoff) || {
                    percentage: 0,
                    correct: 0,
                    total: 0,
                    timestamp: null
                };
                return {
                    name: u.name || 'Unknown',
                    latestScore: best.percentage,
                    latestCorrect: best.correct,
                    latestTotal: best.total,
                    timestamp: best.timestamp,
                    phone: u.phone || '',
                    email: u.email || ''
                };
            });

            // Sort by percentage (desc), then total (desc)
            ranked.sort((a, b) => {
                if (b.latestScore !== a.latestScore) return b.latestScore - a.latestScore;
                return b.latestTotal - a.latestTotal;
            });

            return ranked;
        }

        /**
         * Merge two user objects to consolidate duplicate records (e.g. legacy deviceId vs new name_deviceId)
         * @param {Object} existing - The existing user object in cache
         * @param {Object} incoming - The new user object to merge in
         * @returns {Object} - The merged user object
         */
        function mergeUserStats(existing, incoming) {
            if (!existing) return incoming;
            if (!incoming) return existing;

            // Clone to avoid mutating original references
            const merged = Object.assign({}, existing, incoming); // Incoming takes precedence for scalar props

            // 1. Merge Scores (deduplicate by timestamp/content)
            const scores1 = Array.isArray(existing.scores) ? existing.scores : [];
            const scores2 = Array.isArray(incoming.scores) ? incoming.scores : [];

            // Create a map by timestamp to deduplicate
            const scoreMap = new Map();
            [...scores1, ...scores2].forEach(s => {
                const ts = s.timestamp || s.time || s.t;
                if (ts) {
                    // key by timestamp + total (to differentiate same-time quizzes if any)
                    const key = `${ts}_${s.totalQuestions || s.total || 0}`;
                    if (!scoreMap.has(key)) {
                        scoreMap.set(key, s);
                    }
                }
            });
            merged.scores = Array.from(scoreMap.values());

            // 2. Merge Device IDs
            const did1 = Array.isArray(existing.deviceIds) ? existing.deviceIds : (existing.deviceId ? [existing.deviceId] : []);
            const did2 = Array.isArray(incoming.deviceIds) ? incoming.deviceIds : (incoming.deviceId ? [incoming.deviceId] : []);
            merged.deviceIds = Array.from(new Set([...did1, ...did2]));

            // 3. Keep the name from the most recently updated record (or prefer longer name)
            // (Here we just let 'incoming' win via Object.assign, but we ensure it's not empty)
            if (!merged.name && existing.name) merged.name = existing.name;

            // 4. Recalculate 'latest' stats from the merged scores to be safe
            // (Optional: standard behavior relies on getBestScoreWithinWindow anyway)

            return merged;
        }

        // Resolve the correct Firestore user document for a deviceId.
        // 1. Try strict ID (sanitizedName_deviceId) if name is known locally.
        // 2. Recovery: Query by deviceId field -> check suffix to find correct migrated doc.
        // 3. Auto-restore identity if found.
        async function resolveUserDocRef(deviceId) {
            try {
                if (!firebaseInitialized) await initFirebase();
                if (!firebaseInitialized || !firestoreDb || !window._fb || !window._fb.getDoc) return null;

                const usersCol = window._fb.collection(firestoreDb, 'users');
                let currentUser = null;
                try { currentUser = JSON.parse(localStorage.getItem('gesCurrentUser') || 'null'); } catch (e) { currentUser = null; }

                // 1. Fast Path: We know the name, check the Strict ID directly
                if (currentUser && currentUser.name && deviceId) {
                    const sanitizedName = sanitizeForDocId(currentUser.name);
                    if (sanitizedName) {
                        const strictId = `${sanitizedName}_${deviceId}`;
                        const docRef = window._fb.doc(firestoreDb, 'users', strictId);
                        const snap = await window._fb.getDoc(docRef).catch(() => null);
                        if (snap && (typeof snap.exists === 'function' ? snap.exists() : snap.exists)) {
                            return { ref: docRef, id: strictId, data: snap.data ? snap.data() : snap };
                        }
                    }
                }

                // 2. Recovery Path: We don't know the name (or strict lookup failed).
                // Query ALL docs where deviceId field matches, then check ID suffix.
                if (deviceId) {
                    try {
                        const q = window._fb.query(usersCol, window._fb.where('deviceId', '==', deviceId));
                        const qs = await window._fb.getDocs(q).catch(() => null);

                        let bestMatch = null;
                        if (qs && typeof qs.forEach === 'function') {
                            qs.forEach(d => {
                                // STRICT VALIDATION: ID must end with underscore + deviceId
                                // This prevents matching unrelated docs or legacy docs (which equal deviceId)
                                const suffix = `_${deviceId}`;
                                if (d.id.endsWith(suffix) && d.id.length > suffix.length) { // ensure pre-suffix part exists
                                    bestMatch = { ref: d.ref, id: d.id, data: d.data() };
                                }
                            });
                        }

                        if (bestMatch) {
                            // RECOVERY SUCCESS: We found the user's migrated account!
                            console.log('Recovered user account via deviceId suffix:', bestMatch.id);

                            // Restore identity locally if missing
                            if (bestMatch.data && bestMatch.data.name && (!currentUser || !currentUser.name)) {
                                const restoredUser = {
                                    name: bestMatch.data.name,
                                    phone: bestMatch.data.phone || '',
                                    email: bestMatch.data.email || ''
                                };
                                localStorage.setItem('gesCurrentUser', JSON.stringify(restoredUser));
                                console.log('Restored local user session:', bestMatch.data.name);
                                // Updates UI immediately if on specific pages? (optional)
                            }
                            return bestMatch;
                        }
                    } catch (e) { console.debug('Recovery query failed:', e); }
                }

                return null;
            } catch (e) {
                console.debug('resolveUserDocRef error:', e);
                return null;
            }
        }

        function isValidQuestion(item) {
            return item &&
                typeof item.question === 'string' &&
                typeof item.options === 'object' &&
                typeof item.answer === 'string' &&
                typeof item.explanation === 'string';
        }

        function createQuestionHash(question) {
            // Create a hash of the entire question to detect true duplicates
            // Includes question, options, answer, and explanation
            return JSON.stringify(question);
        }

        async function fetchJsonFilesRecursively(basePath = '.') {
            // Optimized: Only scan existing files in the default-questions folder

            const allQuestionsLoaded = [];
            const seenHashes = new Set();

            // Cache busting: add timestamp to prevent browser caching
            const cacheBuster = `v=${Date.now()}`;

            // Target only the default-questions folder with set files
            const filesToTry = [];
            for (let i = 1; i <= 50; i++) {
                filesToTry.push(`default-questions/set${i}.json`);
            }

            let filesProcessed = 0;
            const existingFiles = []; // Store only confirmed existing files

            // First pass: Check which files exist without loading them
            for (const filePath of filesToTry) {
                try {
                    const headResponse = await fetch(filePath, { method: 'HEAD' });
                    if (headResponse.ok) {
                        existingFiles.push(filePath);
                    }
                } catch (e) {
                    // Silently skip - file doesn't exist or fetch not supported
                }
            }

            const totalFiles = existingFiles.length;
            if (totalFiles === 0) return allQuestionsLoaded; // No files found, return empty

            // Second pass: Load only existing files
            for (const filePath of existingFiles) {
                try {
                    // Append cache buster to the URL
                    const urlWithCacheBuster = `${filePath}?${cacheBuster}`;
                    const response = await fetch(urlWithCacheBuster);
                    filesProcessed++;

                    // Update progress bar
                    const progressPercent = (filesProcessed / totalFiles) * 100;
                    document.getElementById('loading-progress').style.width = progressPercent + '%';
                    document.getElementById('loading-count').textContent = `${allQuestionsLoaded.length} questions loaded | Loading set${filesProcessed} of ${totalFiles}...`;

                    if (!response.ok) continue; // Skip if file can't be read

                    // Load raw text to capture source file and approximate line numbers
                    const rawText = await response.text();
                    let data;
                    try {
                        data = JSON.parse(rawText);
                    } catch (e) {
                        console.debug(`Failed to parse JSON from ${filePath}:`, e);
                        continue; // skip file if not valid JSON
                    }
                    if (!Array.isArray(data)) continue;

                    // Validate and deduplicate, attach source metadata
                    let validCount = 0;
                    for (let i = 0; i < data.length; i++) {
                        const item = data[i];
                        if (isValidQuestion(item)) {
                            const hash = createQuestionHash(item);
                            if (!seenHashes.has(hash)) {
                                seenHashes.add(hash);
                                // Attach source metadata so we can identify file and approximate line later
                                try {
                                    // Attempt to find the stringified item in the raw text to get a line number
                                    const itemString = JSON.stringify(item);
                                    let idx = rawText.indexOf(itemString);
                                    // If not found, try a more robust approach using the question text
                                    if (idx === -1 && item.question) {
                                        idx = rawText.indexOf(item.question);
                                    }
                                    const lineNumber = idx === -1 ? null : (rawText.slice(0, idx).split('\n').length + 1);
                                    const enriched = Object.assign({}, item, {
                                        __sourceFile: filePath,
                                        __sourceIndex: i,
                                        __sourceLine: lineNumber
                                    });
                                    allQuestionsLoaded.push(enriched);
                                    validCount++;
                                } catch (e) {
                                    // Fallback: still include item without line info
                                    allQuestionsLoaded.push(Object.assign({}, item, { __sourceFile: filePath, __sourceIndex: i, __sourceLine: null }));
                                    validCount++;
                                }
                            }
                        }
                    }

                    if (validCount > 0) {
                        console.log(`Successfully loaded ${validCount} questions from: ${filePath}`);
                        document.getElementById('loading-status').textContent = `Found ${validCount} questions in set${filesProcessed}.json`;
                    }
                } catch (e) {
                    // Silently skip files that fail to parse
                    console.debug(`Skipped ${filePath}:`, e.message);
                }
            }

            return allQuestionsLoaded;
        }

        async function loadState() {
            // Show loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            loadingIndicator.classList.remove('hidden');

            // 1. Recursively load and merge all valid JSON files from base directory
            try {
                console.log("Starting to load questions from available sources...");
                let loadedQuestions = await fetchJsonFilesRecursively();

                // Update progress bar
                document.getElementById('loading-progress').style.width = '100%';
                document.getElementById('loading-status').textContent = 'Organizing questions...';

                if (loadedQuestions.length > 0) {
                    console.log(`Successfully loaded ${loadedQuestions.length} unique questions`);
                    document.getElementById('loading-count').textContent = `${loadedQuestions.length} questions loaded`;

                    // Restructure IDs to be sequential
                    allQuestions = loadedQuestions.map((q, index) => ({
                        ...q,
                        id: index + 1
                    }));
                    quizTitleEl.textContent = `Quiz Loaded: ${allQuestions.length} Total Questions`;
                    showMessage(`Loaded ${allQuestions.length} questions from ${loadedQuestions.length} sources (duplicates removed).`, 'info');
                } else {
                    throw new Error('No valid question files found');
                }
            } catch (e) {
                console.error("Error loading question files:", e);
                document.getElementById('loading-status').textContent = 'Error loading questions, checking cache...';

                // Fallback: try local storage, then empty state
                const savedQuestions = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedQuestions) {
                    try {
                        allQuestions = JSON.parse(savedQuestions);
                        quizTitleEl.textContent = `Quiz Loaded: ${allQuestions.length} Total Questions (from cache)`;
                        showMessage(`Loaded ${allQuestions.length} questions from cache.`, 'info');
                    } catch (parseErr) {
                        console.error("Error parsing cached questions:", parseErr);
                        allQuestions = [];
                        showMessage('Could not load questions. Please go to Management to upload a quiz file.', 'error');
                    }
                } else {
                    allQuestions = [];
                    showMessage('Could not find any question files. Please go to Management to upload a quiz file.', 'error');
                }
            }

            // 2. Load Settings
            const savedSettings = localStorage.getItem(SETTINGS_KEY);
            if (savedSettings) {
                try {
                    const loadedSettings = JSON.parse(savedSettings);
                    // Preserve exact TTS enabled state from localStorage, fallback to default in quizSettings
                    loadedSettings.ttsEnabled = loadedSettings.hasOwnProperty('ttsEnabled') ? loadedSettings.ttsEnabled : quizSettings.ttsEnabled;
                    loadedSettings.ttsVoice = loadedSettings.ttsVoice || null;
                    loadedSettings.ttsRate = loadedSettings.ttsRate || 1;
                    loadedSettings.ttsPitch = loadedSettings.ttsPitch || 1;
                    loadedSettings.timeLimit = loadedSettings.timeLimit || 0;


                    loadedSettings.numQuestions = Math.min(loadedSettings.numQuestions, allQuestions.length);
                    Object.assign(quizSettings, loadedSettings);
                    console.log("Settings loaded. TTS Enabled:", quizSettings.ttsEnabled);
                } catch (e) {
                    console.error("Error parsing saved settings:", e);
                }
            } else {
                // No saved settings found: persist current defaults (reader on by default)
                try {
                    saveSettings();
                    console.log('No saved settings found - persisted default settings.');
                } catch (e) {
                    console.warn('Could not persist default settings:', e);
                }
            }

            // 3. Initialize TTS
            initializeTts();

            // 4. Load session history
            loadSessionHistory();

            // 5. Initialize Firebase first so registration checks can query Firestore
            try {
                await initFirebase();
            } catch (e) {
                console.debug('Firebase init skipped or failed (will fallback to jsonbin):', e);
            }

            // Ensure device is registered on the remote leaderboard store
            try {
                await ensureRegistered();
            } catch (e) {
                console.error('Registration check failed:', e);
                // allow app to continue but user will need to register to start sessions
            }

            // Attempt one-time migration from JSONBin -> Firebase (non-blocking)
            try {
                try { await migrateJsonbinToFirebase(); } catch (e) { console.debug('Migration error (non-fatal)', e); }
                try { await migrateUsersJsonbinToFirebase(); } catch (e) { console.debug('User migration error (non-fatal)', e); }
            } catch (e) {
                console.debug('Firebase migration step encountered an error (non-fatal):', e);
            }

            // 6. Re-render based on loaded state
            setView(currentView);
            // Start online monitoring once the app has rendered
            try { startOnlineMonitoring(); } catch (e) { console.debug('Could not start online monitoring:', e); }

            // 6. Hide loading indicator
            setTimeout(() => {
                document.getElementById('loading-indicator').classList.add('hidden');
            }, 500); // Small delay for smooth transition
        }

        function saveQuestions(questions) {
            allQuestions = questions;
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(questions));
                quizTitleEl.textContent = `Quiz Loaded: ${allQuestions.length} Total Questions`;
                showMessage(`Successfully loaded and saved ${questions.length} questions.`, 'success');
            } catch (e) {
                showMessage('Could not save data to local storage.', 'error');
                console.error("Local storage error:", e);
            }
        }

        function saveSettings() {
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(quizSettings));
                showMessage('Settings saved successfully.', 'success');
            } catch (e) {
                showMessage('Could not save settings.', 'error');
                console.error("Local storage error:", e);
            }
        }

        // --- NATIVE TTS IMPLEMENTATION ---

        function initializeTts() {
            const synth = window.speechSynthesis;
            if (!synth) {
                console.warn("Browser Speech Synthesis not supported.");
                quizSettings.ttsEnabled = false; // Disable TTS if not supported
                return;
            }
            console.log("TTS initialized successfully");

            function populateVoiceList() {
                voices = synth.getVoices().filter(v => v.lang.startsWith('en')); // Filter for English voices
                console.log(`Found ${voices.length} English voices available`);
                if (voices.length === 0) {
                    console.warn("No English voices found for TTS (may load shortly).");
                    // Do not disable the reader here — voices sometimes load async via onvoiceschanged.
                } else {
                    console.log("Available voices:", voices.map(v => v.name));
                }
                // If a view is active that needs the voice list, re-render it
                if (currentView === 'settings') {
                    renderSettingsView();
                }
            }

            populateVoiceList();
            if (synth.onvoiceschanged !== undefined) {
                synth.onvoiceschanged = populateVoiceList;
                console.log("Voice change listener attached");
            }
            // Ensure UI buttons reflect the current reader setting after initialization
            try {
                updateTtsButtons();
            } catch (e) {
                console.warn('updateTtsButtons not available yet:', e);
            }
        }

        function speak(text) {
            const synth = window.speechSynthesis;
            if (!quizSettings.ttsEnabled || !synth || !text) return;

            // Cancel any ongoing speech
            synth.cancel();

            // Remove asterisks for TTS (they're just formatting)
            const cleanText = text.replace(/\*\*/g, '');
            const utterance = new SpeechSynthesisUtterance(cleanText);

            // Find the selected voice
            if (quizSettings.ttsVoice) {
                const selectedVoice = voices.find(v => v.voiceURI === quizSettings.ttsVoice);
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }
            }

            utterance.rate = quizSettings.ttsRate;
            utterance.pitch = quizSettings.ttsPitch;

            utterance.onerror = (event) => {
                console.error('SpeechSynthesisUtterance.onerror', event);
                showMessage('An error occurred during speech synthesis.', 'error');
            };

            synth.speak(utterance);
        }

        function toggleTts() {
            quizSettings.ttsEnabled = !quizSettings.ttsEnabled;
            if (!quizSettings.ttsEnabled) {
                window.speechSynthesis.cancel(); // Stop speech immediately
            } else {
                // Re-speak current content when TTS is toggled on during a session
                if (sessionQuestions.length > 0) {
                    const q = sessionQuestions[currentQuestionIndex];
                    if (q) {
                        if (feedbackShown) {
                            // If feedback is shown, speak the feedback
                            const userAnswer = userAnswers[q.id];
                            let feedbackText = `${userAnswer === q.answer ? 'Correct' : 'Incorrect'}. ${q.explanation} so the correct answer is ${q.answer}: ${q.options[q.answer]}.`;
                            speak(feedbackText);
                        } else {
                            // If no feedback shown yet, speak the question
                            let textToSpeak = `Question ${currentQuestionIndex + 1}. ${q.question}. Options: `;
                            textToSpeak += Object.entries(q.options).map(([key, value]) => `Option ${key}: ${value}.`).join(' ');
                            speak(textToSpeak);
                        }
                    }
                }
            }
            saveSettings();
            updateTtsButtons();
            showMessage(`Reader is now ${quizSettings.ttsEnabled ? 'Enabled' : 'Disabled'}.`, 'info');
        }

        function updateTtsButtons() {
            const buttonIds = ['tts-toggle-btn', 'tts-toggle-btn-pre'];
            buttonIds.forEach(id => {
                const buttonEl = document.getElementById(id);
                if (buttonEl) {
                    if (quizSettings.ttsEnabled) {
                        buttonEl.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                        buttonEl.classList.add('bg-green-500', 'text-white', 'hover:bg-green-600');
                        buttonEl.innerHTML = `<svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.47-9.544a8 8 0 010 12.728m-9.544-2.47a5 5 0 017.072 0M6 18h2V6H6v12zm-3 0h2V6H3v12zm18 0h2V6h-2v12z"></path></svg>Reader ON`;
                    } else {
                        buttonEl.classList.remove('bg-green-500', 'text-white', 'hover:bg-green-600');
                        buttonEl.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                        buttonEl.innerHTML = `<svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.47-9.544a8 8 0 010 12.728m-9.544-2.47a5 5 0 017.072 0M6 18h2V6H6v12zm-3 0h2V6H3v12zm18 0h2V6h-2v12zM7 9l4-4 4 4m-4 4v7"></path></svg>Reader OFF`;
                    }
                }
            });
        }

        // Timer control function
        function updateTimerFromInput() {
            const inputEl = document.getElementById('timer-input-pre');
            if (inputEl) {
                let value = parseInt(inputEl.value) || 0;
                // Clamp value between 0 and 180
                value = Math.max(0, Math.min(180, value));
                quizSettings.timeLimit = value;
                inputEl.value = value; // Update input to clamped value
                saveSettings();
                renderHomeView(); // Re-render to update the info display
                const msg = value > 0 ? `Timer set to ${value} minutes` : 'Timer disabled';
                showMessage(msg, 'info');
            }
        }


        // --- View Management ---

        function goBack() {
            setView(previousView);
        }

        function setView(view) {
            // Track previous view before changing
            if (view !== 'home' || currentView !== 'home') {
                previousView = currentView;
            }
            currentView = view;
            window.speechSynthesis.cancel(); // Stop speech when changing views

            // Reset navigation button styles
            document.querySelectorAll('nav button').forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('text-gray-700', 'hover:bg-gray-100');
            });
            const navButton = document.getElementById(`nav-${view}`);
            if (navButton) {
                navButton.classList.remove('text-gray-700', 'hover:bg-gray-100');
                navButton.classList.add('bg-blue-500', 'text-white');
            }

            // Render the content for the selected view
            if (view === 'home') {
                renderHomeView();
            } else if (view === 'management') {
                renderManagementView();
            } else if (view === 'settings') {
                renderSettingsView();
            } else if (view === 'leaderboard') {
                renderLeaderboardView();
            } else if (view === 'graph') {
                renderProgressGraphView();
            } else if (view === 'register') {
                renderRegistrationView();
            } else if (view === 'rankings') {
                renderRankingsView();
                // Start auto-refresh for rankings while this view is active
                try { startRankingsAutoRefresh(); } catch (e) { console.debug('Could not start rankings auto-refresh:', e); }
            }
            // Stop rankings auto-refresh when leaving rankings view
            if (view !== 'rankings') {
                try { stopRankingsAutoRefresh(); } catch (e) { /* silent */ }
            }
            // (Monitoring is started once after loadState; do not start/stop per view)
        }

        // Disable or enable top navigation buttons (used to lock tabs during registration)
        function setNavDisabled(disabled) {
            try {
                const navButtons = document.querySelectorAll('nav button');
                navButtons.forEach(btn => {
                    btn.disabled = !!disabled;
                    if (disabled) {
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                        btn.classList.remove('hover:bg-gray-100');
                        btn.setAttribute('aria-disabled', 'true');
                        btn.tabIndex = -1;
                    } else {
                        btn.classList.remove('opacity-50', 'cursor-not-allowed');
                        btn.classList.add('hover:bg-gray-100');
                        btn.removeAttribute('aria-disabled');
                        btn.tabIndex = 0;
                    }
                });
            } catch (e) {
                console.debug('Could not toggle nav disabled state:', e);
            }
        }

        function renderHomeView() {
            if (allQuestions.length === 0) {
                contentArea.innerHTML = `
                    <div class="text-center p-8 bg-yellow-50 rounded-lg border-2 border-yellow-300">
                        <h3 class="text-2xl font-bold text-yellow-800 mb-4">No Quiz Data Loaded</h3>
                        <p class="text-gray-700 mb-6">Please go to the "Management" section to upload a quiz file or ensure 'questions.json' is present.</p>
                        <button onclick="setView('management')" class="w-full sm:w-auto px-6 py-3 bg-yellow-600 text-white font-bold rounded-lg hover:bg-yellow-700 transition duration-150 shadow-md">
                            Go to Management
                        </button>
                    </div>
                `;
                return;
            }

            contentArea.innerHTML = `
                    <div id="quiz-pre-start" class="text-center p-6 sm:p-8">
                    <h2 class="text-3xl font-bold text-gray-800 mb-4">Start Your Study Session</h2>
                    <div id="online-counter" class="text-lg font-semibold text-gray-700 mb-3">— users online</div>
                    <p class="text-lg text-blue-600 mb-2 cursor-pointer hover:underline hover:text-blue-700 font-semibold flex items-center justify-center gap-2" onclick="setView('settings')" role="button" tabindex="0" aria-label="Open settings" onkeydown="if(event.key === 'Enter' || event.key === ' ') setView('settings')">
                        <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0a1.724 1.724 0 002.196 1.17c.957-.34 1.98.418 1.648 1.363a1.724 1.724 0 001.102 2.16c.92.381.92 1.724 0 2.105a1.724 1.724 0 00-1.102 2.16c.332.945-.691 1.703-1.648 1.363a1.724 1.724 0 00-2.196 1.17c-.299.921-1.602.921-1.902 0a1.724 1.724 0 00-2.196-1.17c-.957.34-1.98-.418-1.648-1.363a1.724 1.724 0 00-1.102-2.16c-.92-.381-.92-1.724 0-2.105a1.724 1.724 0 001.102-2.16c-.332-.945.691-1.703 1.648-1.363.83.295 1.76-.17 2.196-1.17z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                        <span>Configure your session and start practicing</span>
                    </p>
                    
                    <div class="inline-flex flex-wrap justify-center space-x-4 p-3 bg-blue-50 rounded-lg shadow-inner mb-6 text-lg font-medium">
                        <span>${quizSettings.numQuestions} Questions</span>
                        <span>|</span>
                        <span>${quizSettings.randomize ? 'Randomized' : 'Sequential'}</span>
                        <span>|</span>
                        <span>${quizSettings.timeLimit > 0 ? quizSettings.timeLimit + ' min Timer' : 'No Timer'}</span>
                    </div>
                    
                    <div class="flex flex-col sm:flex-row justify-center gap-4">
                         <button id="tts-toggle-btn-pre" onclick="toggleTts()" class="flex items-center justify-center px-6 py-3 font-bold rounded-xl transition duration-150 shadow-md">
                            <!-- Button content will be updated by updateTtsButton -->
                        </button>
                        <div class="flex items-center gap-2 bg-white px-4 py-2 rounded-xl shadow-md border border-gray-200">
                            <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            <label for="timer-input-pre" class="text-sm font-semibold text-gray-700">Timer:</label>
                            <input type="number" id="timer-input-pre" min="0" max="180" value="${quizSettings.timeLimit || 0}" onchange="updateTimerFromInput()" class="w-20 p-2 border border-gray-300 rounded-lg text-center focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="0">
                            <span class="text-sm text-gray-600 font-medium">min</span>
                        </div>
                        <button onclick="startSession()" class="w-full sm:w-auto px-10 py-4 bg-green-600 text-white font-extrabold text-xl rounded-xl hover:bg-green-700 transition duration-150 shadow-lg transform hover:scale-105">
                            Start Session (${quizSettings.numQuestions} Qs)
                        </button>
                        <button onclick="setView('leaderboard')" class="w-full sm:w-auto px-6 py-3 bg-indigo-600 text-white font-bold rounded-xl hover:bg-indigo-700 transition duration-150 shadow-md">
                            View Leaderboard
                        </button>
                    </div>
                    
                    <p class="mt-6 text-gray-500 text-sm">You can change these settings in the 'Settings' tab.</p>
                </div>
                
                <div id="quiz-container" class="hidden">
                    <div id="timer-bar" class="hidden bg-gray-100 border-b-2 border-gray-300 text-gray-800 p-3 mb-4 rounded-t-lg flex justify-between items-center sticky top-0 z-30 shadow-md">
                        <div class="flex items-center space-x-4">
                            <span id="score-display" class="font-bold text-lg text-green-700 bg-green-100 px-3 py-1 rounded-full border border-green-200 shadow-sm">
                                Score: 0
                            </span>
                        </div>
                        <span id="timer-container" class="font-bold text-lg flex items-center text-red-700 bg-red-100 px-3 py-1 rounded-full border border-red-200 shadow-sm">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            <span id="timer-display" class="font-mono text-xl">00:00</span>
                        </span>
                    </div>
                    <div class="flex justify-end gap-2 mb-4">
                        <button id="tts-toggle-btn" onclick="toggleTts()" class="flex items-center px-4 py-2 text-sm font-bold rounded-full transition duration-150 shadow-md">
                            <!-- Button content will be updated by updateTtsButton -->
                        </button>
                        <button id="quit-quiz-btn" onclick="confirmQuitQuiz()" class="flex items-center px-4 py-2 text-sm font-bold rounded-full bg-red-500 text-white hover:bg-red-600 transition duration-150 shadow-md" style="display: ${reviewMode ? 'none' : 'block'};">Quit Quiz</button>
                    </div>
                    <div id="question-area"></div>
                    <div id="feedback-area" class="mt-6 hidden"></div>
                    <div id="action-buttons" class="mt-8 flex justify-between items-center flex-wrap gap-4"></div>
                    <div id="navigation-area" class="mt-8"></div>
                    <div id="progress-bar" class="mt-8"></div>
                </div>
            `;
            updateTtsButtons();
            if (Object.keys(userAnswers).length > 0) {
                document.getElementById('quiz-pre-start').classList.add('hidden');
                document.getElementById('quiz-container').classList.remove('hidden');
                renderQuestion();
            }
        }

        function renderManagementView() {
            contentArea.innerHTML = `
                <h2 class="text-3xl font-bold text-gray-800 mb-6">Quiz Management & Import/Export</h2>
                <div class="space-y-6">
                    <div class="p-6 bg-white border border-gray-200 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold text-blue-700 mb-3">Upload Quiz Files (JSON)</h3>
                        <p class="text-gray-600 mb-4">Select one or more JSON files. New uploads will <span class="font-bold text-red-500">REPLACE</span> the current question set.</p>
                        <input type="file" id="quizFileInput" accept=".json" multiple class="hidden" onchange="handleFileSelection(event)">
                        <label for="quizFileInput" class="custom-file-input rounded-lg block">
                            <svg class="w-8 h-8 mx-auto text-blue-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                            <span id="upload-label" class="text-blue-500 font-medium">Click to select JSON file(s)</span>
                        </label>
                        <ul id="file-list" class="file-list italic pl-4 list-disc">No files selected.</ul>
                        <button id="process-files-btn" onclick="processSelectedFiles()" class="mt-4 w-full sm:w-auto px-6 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md disabled:bg-gray-400" disabled>
                            Process & Load Questions
                        </button>
                        <div class="mt-4 text-sm text-gray-500">Current Quiz Questions Loaded: <span class="font-bold text-blue-600">${allQuestions.length}</span></div>
                    </div>
                    <div class="p-6 bg-white border border-gray-200 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold text-blue-700 mb-3">Download Options</h3>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <button onclick="downloadTemplate()" class="flex items-center justify-center w-full px-4 py-3 bg-indigo-500 text-white font-bold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                                Download Template
                            </button>
                            <button onclick="downloadQuiz()" class="flex items-center justify-center w-full px-4 py-3 bg-purple-500 text-white font-bold rounded-lg hover:bg-purple-600 transition duration-150 shadow-md">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.885 2.624L7 20h10l.885-1.376A4 4 0 0117 16V9a2 2 0 00-2-2h-1"></path></svg>
                                Download Current Quiz (${allQuestions.length} Qs)
                            </button>
                        </div>
                    </div>
                    <div class="p-6 bg-red-50 border border-red-200 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold text-red-700 mb-3">Reset to Default</h3>
                        <p class="text-gray-600 mb-4">This will clear any uploaded quiz and reload from the original 'questions.json' file.</p>
                        <button onclick="confirmReset()" class="w-full sm:w-auto px-4 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition duration-150 shadow-md">
                            Reset Quiz Data
                        </button>
                    </div>
                </div>
            `;
        }

        function renderSettingsView() {
            const maxQ = allQuestions.length > 0 ? allQuestions.length : 1;

            let voiceOptions = '<option value="">Default</option>';
            if (voices.length > 0) {
                voiceOptions = voices.map(voice =>
                    `<option value="${voice.voiceURI}" ${quizSettings.ttsVoice === voice.voiceURI ? 'selected' : ''}>
                        ${voice.name} (${voice.lang})
                    </option>`
                ).join('');
            }

            contentArea.innerHTML = `
                <h2 class="text-3xl font-bold text-gray-800 mb-6">Study Session Settings</h2>
                <div class="p-6 bg-white border border-gray-200 rounded-xl shadow-md space-y-6">
                    
                    <div>
                        <label for="numQuestions" class="block text-lg font-semibold text-gray-700 mb-2">Questions per Session</label>
                        <p class="text-sm text-gray-500 mb-3">Set how many questions you want in a session. (Max: ${maxQ})</p>
                        <input type="range" id="numQuestions" min="1" max="${maxQ}" value="${quizSettings.numQuestions}" oninput="updateSettingsAuto(); document.getElementById('numQInput').value = this.value" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <div class="flex justify-between items-center text-sm text-gray-600 mt-2">
                            <span>1</span>
                            <input type="number" id="numQInput" min="1" max="${maxQ}" value="${quizSettings.numQuestions}" onchange="if(this.value > ${maxQ}) this.value = ${maxQ}; if(this.value < 1) this.value = 1; document.getElementById('numQuestions').value = this.value; updateSettingsAuto();" class="w-24 px-3 py-2 border border-gray-300 rounded-lg text-center font-semibold text-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <span>${maxQ}</span>
                        </div>
                    </div>

                    <div class="flex items-center justify-between border-t pt-4">
                        <label for="randomize" class="text-lg font-semibold text-gray-700">Randomize Question Order</label>
                        <input type="checkbox" id="randomize" ${quizSettings.randomize ? 'checked' : ''} onchange="updateSettingsAuto()" class="w-5 h-5 text-blue-600 rounded">
                    </div>
                
                    <div class="border-t pt-4">
                        <label for="timeLimit" class="block text-lg font-semibold text-gray-700 mb-2">Timer (Minutes)</label>
                        <p class="text-sm text-gray-500 mb-3">Set a time limit for your quiz. Set to 0 to disable.</p>
                        <div class="flex items-center gap-4">
                            <input type="number" id="timeLimit" min="0" max="180" value="${quizSettings.timeLimit || 0}" onchange="updateSettingsAuto()" class="w-full sm:w-1/3 p-3 border border-gray-300 rounded-lg text-lg focus:ring-2 focus:ring-blue-500 focus:outline-none placeholder-gray-400" placeholder="e.g. 30">
                            <span class="text-gray-600 font-medium">min</span>
                        </div>
                    </div>
                    
                    <div class="border-t pt-4 space-y-4">
                        <h3 class="text-xl font-semibold text-gray-800">Text-to-Speech (TTS)</h3>
                        <div class="flex items-center justify-between">
                            <label for="ttsEnabled" class="text-lg font-semibold text-gray-700">Enable Reader</label>
                            <input type="checkbox" id="ttsEnabled" ${quizSettings.ttsEnabled ? 'checked' : ''} onchange="updateSettingsAuto()" class="w-5 h-5 text-blue-600 rounded">
                        </div>

                        <div>
                            <label for="ttsVoice" class="block text-lg font-semibold text-gray-700 mb-2">Voice</label>
                            <div class="flex gap-2">
                                <select id="ttsVoice" onchange="updateSettingsAuto(); testVoice()" class="flex-1 p-2 border border-gray-300 rounded-lg bg-white">${voiceOptions}</select>
                                <button onclick="testVoice()" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 whitespace-nowrap">Test Voice</button>
                            </div>
                        </div>

                        <div>
                            <label for="ttsRate" class="block text-lg font-semibold text-gray-700 mb-2">Rate: <span id="ttsRateValue">${quizSettings.ttsRate}</span></label>
                            <input type="range" id="ttsRate" min="0.5" max="2" step="0.1" value="${quizSettings.ttsRate}" oninput="updateSettingsAuto(); document.getElementById('ttsRateValue').textContent = this.value" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>

                        <div>
                            <label for="ttsPitch" class="block text-lg font-semibold text-gray-700 mb-2">Pitch: <span id="ttsPitchValue">${quizSettings.ttsPitch}</span></label>
                            <input type="range" id="ttsPitch" min="0" max="2" step="0.1" value="${quizSettings.ttsPitch}" oninput="updateSettingsAuto(); document.getElementById('ttsPitchValue').textContent = this.value" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div class="border-t pt-4">
                        <h3 class="text-xl font-semibold text-gray-800">Admin</h3>
                        <p class="text-sm text-gray-600 mb-3">View and manage questions reported by users. Requires admin password.</p>
                        <button onclick="promptAdminAndShowReports()" class="px-4 py-2 bg-yellow-600 text-white rounded-lg font-semibold hover:bg-yellow-700">View Reported Questions (Admin)</button>
                    </div>
                </div>
            `;
        }

        // --- Settings Logic ---

        function updateSettingsAuto() {
            quizSettings.numQuestions = parseInt(document.getElementById('numQuestions').value, 10);
            quizSettings.randomize = document.getElementById('randomize').checked;
            quizSettings.ttsEnabled = document.getElementById('ttsEnabled').checked;
            quizSettings.ttsVoice = document.getElementById('ttsVoice').value;
            quizSettings.ttsRate = parseFloat(document.getElementById('ttsRate').value);
            quizSettings.ttsPitch = parseFloat(document.getElementById('ttsPitch').value);
            // Handle timer input (allow empty/null to mean 0)
            const tEl = document.getElementById('timeLimit');
            if (tEl) {
                const val = parseInt(tEl.value, 10);
                quizSettings.timeLimit = isNaN(val) ? 0 : val;
            }

            saveSettings();
            updateTtsButtons();
        }

        function formatText(text) {
            if (!text && text !== 0) return '';
            let formatted = String(text);

            // Normalize common newline markers: actual newlines, literal \n, or /n
            // Replace with <br> for HTML display
            try {
                formatted = formatted.replace(/\\r\\n|\\r|\\n/g, '<br>'); // actual newlines
            } catch (e) { }
            try {
                formatted = formatted.replace(/\\n/g, '<br>'); // literal backslash-n
            } catch (e) { }
            try {
                formatted = formatted.replace(/\/n/g, '<br>'); // slash-n
            } catch (e) { }

            // Replace **text** with bold span
            formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<span class="text-blue-700 font-bold">$1</span>');

            // Replace *text* with bold span (single asterisks)
            formatted = formatted.replace(/\*([^*]+)\*/g, '<span class="text-blue-700 font-bold">$1</span>');

            // Replace 'text' with bold span only when surrounded by whitespace or string boundaries
            // This avoids matching possessive forms like "teacher's"
            formatted = formatted.replace(/(^|\s)'([^']+)'(\s|$)/g, function (_, pre, inner, post) {
                return (pre || '') + `<span class="text-blue-700 font-bold">${inner}</span>` + (post || '');
            });

            // Add line breaks before listed items (Roman numerals, letters, or numbers followed by period/parenthesis)
            formatted = formatted.replace(/\s+((?:[IVX]+|[A-Za-z]|[0-9]+)[\.\)]\s+)/g, '<br>$1');

            return formatted;
        }

        // --- Device registration & JSONBin.io integration ---

        function uuidv4() {
            // Simple UUID generator
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function getDeviceId() {
            try {
                let id = localStorage.getItem('gesDeviceId');
                if (!id) {
                    id = uuidv4();
                    localStorage.setItem('gesDeviceId', id);
                }


                return id;
            } catch (e) {
                console.error('Could not access localStorage for device id:', e);
                return null;
            }
        }

        // Returns true if a user has completed registration (local marker)
        function isUserRegistered() {
            try {
                const cu = localStorage.getItem('gesCurrentUser');
                if (!cu) return false;
                const parsed = JSON.parse(cu);
                return !!(parsed && parsed.deviceId);
            } catch (e) {
                return false;
            }
        }

        async function fetchJsonBinData(binId = JSONBIN_BIN_ID) {
            if (!binId || !JSONBIN_MASTER_KEY) throw new Error('JSONBin not configured');
            const url = `https://api.jsonbin.io/v3/b/${binId}/latest`;
            const resp = await fetch(url, {
                method: 'GET',
                headers: {
                    'X-Master-Key': JSONBIN_MASTER_KEY
                }
            });
            if (!resp.ok) throw new Error(`jsonbin GET failed: ${resp.status}`);
            const body = await resp.json();
            // v3 returns { record: ... }
            return body && (body.record || body);
        }

        // --- Location detection (city, country) - top-level implementations ---
        async function getUserLocation() {
            try {
                // First try browser geolocation (user permission required)
                const geo = await new Promise((resolve, reject) => {
                    if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
                    const opts = { enableHighAccuracy: false, timeout: 8000, maximumAge: 5 * 60 * 1000 };
                    navigator.geolocation.getCurrentPosition(pos => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }), err => reject(err), opts);
                }).catch(() => null);

                let city = null, country = null;

                if (geo && geo.lat != null) {
                    // Reverse geocode using OpenStreetMap Nominatim (best-effort)
                    try {
                        const r = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(geo.lat)}&lon=${encodeURIComponent(geo.lon)}`);
                        if (r.ok) {
                            const j = await r.json();
                            const addr = j && j.address ? j.address : {};
                            city = addr.city || addr.town || addr.village || addr.hamlet || addr.county || null;
                            country = addr.country || addr.country_code || null;
                        }
                    } catch (e) {
                        console.debug('Nominatim reverse geocode failed, falling back to IP geolocation:', e);
                    }
                }

                // Fallback: IP-based geolocation (no API key, rate-limited) if we have no city/country
                if ((!city || !country)) {
                    try {
                        const resp = await fetch('https://ipapi.co/json/');
                        if (resp.ok) {
                            const info = await resp.json();
                            city = city || info.city || null;
                            country = country || info.country_name || info.country || null;
                        }
                    } catch (e) {
                        console.debug('IP geolocation fallback failed (silent):', e);
                    }
                }

                const loc = { city: city || null, country: country || null };
                try { localStorage.setItem('gesDeviceLocation', JSON.stringify(loc)); } catch (e) { }
                // If we have a newly-detected location, attempt to update the user's record in the background
                try { updateUserLocationIfBetter(loc); } catch (e) { /* silent */ }
                return loc;
            } catch (e) {
                // Any failure: return stored value if present, or nulls
                try {
                    const stored = JSON.parse(localStorage.getItem('gesDeviceLocation') || '{}');
                    return { city: stored.city || null, country: stored.country || null };
                } catch (ee) {
                    return { city: null, country: null };
                }
            }
        }

        async function detectAndFillLocationInputs() {
            try {
                const loc = await getUserLocation();
                if (!loc) return;
                const cityEl = document.getElementById('reg-city');
                const countryEl = document.getElementById('reg-country');
                if (cityEl && loc.city) cityEl.value = loc.city;
                if (countryEl && loc.country) countryEl.value = loc.country;
                // If we got a location, also attempt to persist it to the user's record
                try { updateUserLocationIfBetter(loc); } catch (e) { console.debug('Could not update user location after detection:', e); }
            } catch (e) {
                console.debug('Could not detect/fill location (silent):', e);
            }
        }

        async function putJsonBinData(newData, binId = JSONBIN_BIN_ID) {
            const url = `https://api.jsonbin.io/v3/b/${binId}`;
            const resp = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Master-Key': JSONBIN_MASTER_KEY
                },
                body: JSON.stringify(newData)
            });
            if (!resp.ok) throw new Error(`jsonbin PUT failed: ${resp.status}`);
            return await resp.json();
        }

        // --- Reporting Problematic Questions ---
        function _createModalContainer(id) {
            let el = document.getElementById(id);
            if (el) return el;
            el = document.createElement('div');
            el.id = id;
            document.body.appendChild(el);
            return el;
        }

        /**
         * Generic custom confirmation modal.
         * @returns {Promise<boolean>} Resolves true if confirmed, false otherwise.
         */
        function showCustomConfirm(title, message, confirmText = "OK", cancelText = "Cancel", confirmColorClass = "bg-blue-600 hover:bg-blue-700") {
            return new Promise((resolve) => {
                const modal = _createModalContainer('custom-confirm-modal');
                // Use a backdrop blur and generic styling
                modal.innerHTML = `
                    <div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm transition-opacity duration-300">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full mx-4 overflow-hidden transform transition-all scale-100">
                            <div class="p-6">
                                <h3 class="text-xl font-bold text-gray-900 mb-2">${title}</h3>
                                <div class="text-gray-600 text-base leading-relaxed mb-6">
                                    ${formatText(message)}
                                </div>
                                <div class="flex justify-end space-x-3">
                                    <button id="modal-cancel-btn" class="px-5 py-2.5 rounded-xl text-gray-700 font-semibold bg-gray-100 hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-300 transition-colors">
                                        ${cancelText}
                                    </button>
                                    <button id="modal-confirm-btn" class="px-5 py-2.5 rounded-xl text-white font-bold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-blue-500 transition-colors ${confirmColorClass}">
                                        ${confirmText}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                const confirmBtn = document.getElementById('modal-confirm-btn');
                const cancelBtn = document.getElementById('modal-cancel-btn');

                const cleanup = () => {
                    modal.innerHTML = '';
                };

                confirmBtn.onclick = () => {
                    cleanup();
                    resolve(true);
                };

                cancelBtn.onclick = () => {
                    cleanup();
                    resolve(false);
                };
            });
        }

        /**
         * Generic custom prompt modal.
         * @returns {Promise<string|null>} Resolves with input value or null if cancelled.
         */
        function showCustomPrompt(title, message, placeholder = "", confirmText = "OK", cancelText = "Cancel") {
            return new Promise((resolve) => {
                const modal = _createModalContainer('custom-prompt-modal');
                modal.innerHTML = `
                    <div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm transition-opacity duration-300">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full mx-4 overflow-hidden transform transition-all scale-100">
                            <div class="p-6">
                                <h3 class="text-xl font-bold text-gray-900 mb-2">${title}</h3>
                                <div class="text-gray-600 text-base leading-relaxed mb-4">
                                    ${formatText(message)}
                                </div>
                                <input id="modal-prompt-input" type="password" placeholder="${placeholder}" class="w-full px-4 py-3 rounded-xl border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-shadow mb-6 text-lg" autofocus />
                                <div class="flex justify-end space-x-3">
                                    <button id="modal-prompt-cancel-btn" class="px-5 py-2.5 rounded-xl text-gray-700 font-semibold bg-gray-100 hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-300 transition-colors">
                                        ${cancelText}
                                    </button>
                                    <button id="modal-prompt-confirm-btn" class="px-5 py-2.5 rounded-xl text-white font-bold shadow-md bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-blue-500 transition-colors">
                                        ${confirmText}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                const input = document.getElementById('modal-prompt-input');
                const confirmBtn = document.getElementById('modal-prompt-confirm-btn');
                const cancelBtn = document.getElementById('modal-prompt-cancel-btn');

                // Auto-focus input
                setTimeout(() => input.focus(), 50);

                const cleanup = () => {
                    modal.innerHTML = '';
                };

                const confirm = () => {
                    const val = input.value;
                    cleanup();
                    resolve(val);
                };

                confirmBtn.onclick = confirm;

                // Allow Enter key to submit
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') confirm();
                    if (e.key === 'Escape') { cleanup(); resolve(null); }
                };

                cancelBtn.onclick = () => {
                    cleanup();
                    resolve(null);
                };
            });
        }

        function openReportDialog() {
            const q = sessionQuestions[currentQuestionIndex];
            if (!q) { showMessage('No question available to report.', 'error'); return; }
            const modal = _createModalContainer('report-modal');
            modal.innerHTML = `
                <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-60">
                    <div class="bg-white rounded-lg p-6 max-w-2xl w-full shadow-2xl">
                        <h3 class="text-xl font-bold mb-2">Report Question</h3>
                        <p class="text-sm text-gray-600 mb-3">Please describe the issue and add optional tags (comma-separated).</p>
                        <div class="mb-3 text-sm text-gray-800 p-3 bg-gray-50 rounded">${formatText(q.question)}</div>
                        <input id="report-tags" placeholder="Tags (e.g. typo,wrong-answer,ambiguous)" class="w-full p-2 border rounded mb-2" />
                        <textarea id="report-comment" placeholder="Comment (what's wrong?)" rows="4" class="w-full p-2 border rounded mb-3"></textarea>
                        <div class="flex justify-end gap-2">
                            <button onclick="closeReportDialog()" class="px-4 py-2 bg-gray-200 rounded">Cancel</button>
                            <button onclick="submitReport()" class="px-4 py-2 bg-yellow-500 text-white rounded">Submit Report</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function closeReportDialog() {
            const modal = document.getElementById('report-modal');
            if (modal) modal.innerHTML = '';
        }

        async function submitReport() {
            try {
                const q = sessionQuestions[currentQuestionIndex];
                if (!q) { showMessage('No question found to report.', 'error'); return; }
                const tagsRaw = (document.getElementById('report-tags') && document.getElementById('report-tags').value) || '';
                const tags = tagsRaw.split(',').map(t => t.trim()).filter(Boolean);
                const comment = (document.getElementById('report-comment') && document.getElementById('report-comment').value.trim()) || null;
                const deviceId = getDeviceId();
                let currentUser = null;
                try { currentUser = JSON.parse(localStorage.getItem('gesCurrentUser') || 'null'); } catch (e) { currentUser = null; }
                // Attempt to include reporter location if available
                let reporterLocation = null;
                try { reporterLocation = JSON.parse(localStorage.getItem('gesDeviceLocation') || 'null'); } catch (e) { reporterLocation = null; }

                // Normalize source file and line information. Some question sources include the line
                // number appended in brackets/parentheses (e.g. "set25.json [123]") — parse that out.
                let sourceFileRaw = q.__sourceFile || null;
                let sourceLineRaw = q.__sourceLine || null;
                if (sourceFileRaw && !sourceLineRaw && typeof sourceFileRaw === 'string') {
                    // Try patterns like: "file.ext [123]", "file.ext (123)", "file.ext:123", "file.ext - line 123"
                    const bracketMatch = sourceFileRaw.match(/^(.*?)\s*[\[\(:\-]\s*line?\s*:?\s*(\d+)\s*[\]\)]?$/i) || sourceFileRaw.match(/^(.*?)[\s]*[\[\(:]\s*(\d+)\s*[\]\)]?$/);
                    if (bracketMatch) {
                        sourceFileRaw = (bracketMatch[1] || '').trim();
                        sourceLineRaw = parseInt(bracketMatch[2], 10) || null;
                    }
                }

                const report = {
                    id: `r_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
                    deviceId,
                    reporterName: currentUser ? (currentUser.name || null) : null,
                    reporterEmail: currentUser ? (currentUser.email || null) : null,
                    reporterLocation: reporterLocation || null,
                    questionId: q.id || null,
                    question: q.question || null,
                    fullQuestionObject: q,
                    sourceFile: sourceFileRaw || null,
                    sourceLine: sourceLineRaw || null,
                    sourceIndex: q.__sourceIndex || null,
                    tags,
                    comment,
                    status: 'open',
                    createdAt: new Date().toISOString()
                };

                await appendReportToJsonBin(report);
                closeReportDialog();
                showMessage('Report submitted. Thank you.', 'success');
            } catch (e) {
                console.error('Failed to submit report:', e);
                showMessage('Could not submit report. Try again later.', 'error');
            }
        }

        async function appendReportToJsonBin(report) {
            // Try to save to Firebase first (preferred). If that fails, fall back to jsonbin.
            try {
                if (!firebaseInitialized) await initFirebase();
                if (firebaseInitialized && firestoreDb && window._fb && window._fb.setDoc) {
                    await window._fb.setDoc(window._fb.doc(firestoreDb, 'reviews', report.id), report);
                    return true;
                }
            } catch (e) {
                console.warn('Saving report to Firebase failed, falling back to jsonbin:', e);
            }

            try {
                // Use the dedicated reviews bin for reports
                const data = await fetchJsonBinData(JSONBIN_REVIEWS_BIN_ID).catch(() => null);
                // Ensure we have an object to modify
                const base = (data && typeof data === 'object') ? data : {};
                base.reports = Array.isArray(base.reports) ? base.reports : [];
                base.reports.push(report);
                await putJsonBinData(base, JSONBIN_REVIEWS_BIN_ID);
                return true;
            } catch (e) {
                console.error('appendReportToJsonBin error (jsonbin fallback):', e);
                throw e;
            }
        }

        // Update status (open/resolved) for a report and persist to the reviews bin
        async function updateReportStatus(reportId, newStatus) {
            // Try Firestore update first (best-effort), then fallback to jsonbin
            try {
                if (!firebaseInitialized) await initFirebase();
                if (firebaseInitialized && firestoreDb && window._fb && window._fb.getDoc && window._fb.setDoc) {
                    try {
                        const docRef = window._fb.doc(firestoreDb, 'reviews', reportId);
                        const snap = await window._fb.getDoc(docRef).catch(() => null);
                        const exists = snap && (typeof snap.exists === 'function' ? snap.exists() : snap.exists);
                        if (!exists) throw new Error('Report not found');
                        const report = snap.data ? snap.data() : (snap && snap.data) || {};
                        report.status = newStatus;
                        if (newStatus === 'resolved') report.resolvedAt = new Date().toISOString();
                        else report.resolvedAt = null;
                        await window._fb.setDoc(docRef, report);
                        return report;
                    } catch (e) {
                        console.debug('Firestore updateReportStatus failed, falling back to jsonbin:', e);
                        // fall through to jsonbin fallback
                    }
                }
            } catch (e) {
                console.debug('updateReportStatus (firestore check) error:', e);
            }

            // Fallback: update in JSONBin
            try {
                const data = await fetchJsonBinData(JSONBIN_REVIEWS_BIN_ID);
                const base = (data && typeof data === 'object') ? data : {};
                base.reports = Array.isArray(base.reports) ? base.reports : [];
                const idx = base.reports.findIndex(r => r.id === reportId);
                if (idx === -1) throw new Error('Report not found');
                base.reports[idx].status = newStatus;
                if (newStatus === 'resolved') base.reports[idx].resolvedAt = new Date().toISOString();
                else base.reports[idx].resolvedAt = null;
                await putJsonBinData(base, JSONBIN_REVIEWS_BIN_ID);
                return base.reports[idx];
            } catch (e) {
                console.error('updateReportStatus error:', e);
                throw e;
            }
        }

        // Replace the whole reports list in the reviews bin (helper)
        async function saveReportsListToBin(reports) {
            try {
                const base = { reports: Array.isArray(reports) ? reports : [] };
                await putJsonBinData(base, JSONBIN_REVIEWS_BIN_ID);
                return true;
            } catch (e) {
                console.error('saveReportsListToBin error:', e);
                throw e;
            }
        }

        // Delete a report permanently (prefer Firestore, fallback to jsonbin)
        async function deleteReport(reportId) {
            // Try Firestore delete first
            try {
                if (!firebaseInitialized) await initFirebase();
                if (firebaseInitialized && firestoreDb && window._fb && window._fb.deleteDoc && window._fb.doc) {
                    const docRef = window._fb.doc(firestoreDb, 'reviews', reportId);
                    await window._fb.deleteDoc(docRef);
                    return true;
                }
            } catch (e) {
                console.debug('Firestore deleteReport failed, falling back to jsonbin:', e);
            }

            // Fallback: remove from JSONBin reviews bin
            try {
                const data = await fetchJsonBinData(JSONBIN_REVIEWS_BIN_ID);
                const base = (data && typeof data === 'object') ? data : {};
                base.reports = Array.isArray(base.reports) ? base.reports : [];
                const idx = base.reports.findIndex(r => r.id === reportId);
                if (idx === -1) throw new Error('Report not found');
                base.reports.splice(idx, 1);
                await putJsonBinData(base, JSONBIN_REVIEWS_BIN_ID);
                return true;
            } catch (e) {
                console.error('deleteReport error (jsonbin fallback):', e);
                throw e;
            }
        }

        // Fetch reports from Firebase (returns array) if available
        async function fetchReportsFromFirebase() {
            if (!firebaseInitialized) await initFirebase();
            if (!firebaseInitialized || !firestoreDb || !window._fb || !window._fb.getDocs) return null;
            try {
                const qs = await window._fb.getDocs(window._fb.collection(firestoreDb, 'reviews'));
                const arr = [];
                qs.forEach(d => arr.push(d.data()));
                return arr;
            } catch (e) {
                console.error('fetchReportsFromFirebase error:', e);
                return null;
            }
        }

        // Helper: load reports preferring Firestore, fallback to JSONBin; returns an object { reports: [...] }
        async function loadReportsObject() {
            try {
                const fbReports = await fetchReportsFromFirebase();
                if (Array.isArray(fbReports) && fbReports.length >= 0) return { reports: fbReports };
            } catch (e) { /* silent */ }
            try {
                const data = await fetchJsonBinData(JSONBIN_REVIEWS_BIN_ID).catch(() => null);
                if (data && typeof data === 'object') return data;
            } catch (e) { /* silent */ }
            return { reports: [] };
        }

        // Read admin password from Firestore document.
        // Document: collection 'adminpassword', id '3hd77Y0mqg69DXNIBco1'
        async function fetchAdminPasswordFromFirebase() {
            try {
                if (!firebaseInitialized) await initFirebase();
                if (!firebaseInitialized || !firestoreDb || !window._fb || !window._fb.getDoc) return null;
                const docRef = window._fb.doc(firestoreDb, 'adminpassword', '3hd77Y0mqg69DXNIBco1');
                const snap = await window._fb.getDoc(docRef);
                if (!snap || (typeof snap.exists === 'function' ? !snap.exists() : !snap.exists)) return null;
                const data = snap.data ? snap.data() : (snap && snap.data) || null;
                if (!data) return null;
                // Try several common field names
                return data.password || data.adminPassword || data.pw || data.value || null;
            } catch (e) {
                console.debug('fetchAdminPasswordFromFirebase error:', e);
                return null;
            }
        }

        // Migrate any reports from JSONBin -> Firebase if missing
        async function migrateJsonbinToFirebase() {
            try {
                if (!firebaseInitialized) await initFirebase();
                if (!firebaseInitialized || !firestoreDb || !window._fb || !window._fb.getDoc) return;
                const data = await fetchJsonBinData(JSONBIN_REVIEWS_BIN_ID).catch(() => null);
                const reports = (data && Array.isArray(data.reports)) ? data.reports : [];
                if (!reports || reports.length === 0) return;
                for (const r of reports) {
                    try {
                        const snap = await window._fb.getDoc(window._fb.doc(firestoreDb, 'reviews', r.id));
                        if (!snap || !snap.exists || !snap.exists()) {
                            // create in firebase
                            await window._fb.setDoc(window._fb.doc(firestoreDb, 'reviews', r.id), r);
                        }
                    } catch (e) {
                        console.debug('Could not migrate report', r && r.id, e);
                    }
                }
                console.log('JSONBin -> Firebase migration complete (best-effort)');
            } catch (e) {
                console.debug('Migration skipped or failed:', e);
            }
        }

        // Migrate user records from the main JSONBin into Firestore 'users' collection
        async function migrateUsersJsonbinToFirebase() {
            try {
                if (!firebaseInitialized) await initFirebase();
                if (!firebaseInitialized || !firestoreDb || !window._fb || !window._fb.getDoc) return;

                const data = await fetchJsonBinData(JSONBIN_BIN_ID).catch(() => null);
                // data may be an array of users, or an object with `users` property
                const usersArr = Array.isArray(data) ? data : (data && Array.isArray(data.users) ? data.users : []);
                if (!usersArr || usersArr.length === 0) {
                    console.debug('No users found in JSONBin for migration');
                    return;
                }

                let migrated = 0;
                for (const u of usersArr) {
                    try {
                        if (!u || !u.deviceId) continue;
                        // Prefer sanitized name id for new documents to allow human-readable ids
                        const sanitizedName = sanitizeForDocId(u && u.name);
                        const preferredId = (sanitizedName && u.deviceId) ? `${sanitizedName}_${u.deviceId}` : (sanitizedName || u.deviceId);
                        const docRef = window._fb.doc(firestoreDb, 'users', preferredId);
                        const snap = await window._fb.getDoc(docRef).catch(() => null);
                        const exists = snap && (typeof snap.exists === 'function' ? snap.exists() : snap.exists);
                        if (!exists) {
                            // Prepare user object to write (avoid storing large arrays of questions)
                            const writeObj = Object.assign({}, u);
                            writeObj.deviceIds = Array.isArray(writeObj.deviceIds) ? Array.from(new Set(writeObj.deviceIds.concat([u.deviceId]))) : [u.deviceId];
                            // Normalize any timestamps
                            writeObj.lastTimestamp = normalizeTimestampToISO(writeObj.lastTimestamp);
                            await window._fb.setDoc(docRef, writeObj).catch(() => null);
                            migrated++;
                        } else {
                            // If a legacy doc exists under deviceId but preferredId is different, avoid overwriting
                        }
                    } catch (e) {
                        console.debug('Failed migrating user', u && u.deviceId, e);
                    }
                }
                console.log(`User migration complete. Migrated ${migrated} users (best-effort).`);
                if (migrated > 0) showMessage(`Migrated ${migrated} user(s) to Firebase.`, 'info');
            } catch (e) {
                console.debug('User migration skipped or failed:', e);
            }
        }

        // Admin: prompt for password then display reported questions
        // [MIGRATED] promptAdminAndShowReports, renderReportsList, etc. moved to reported_questions.js

        // registration promise control so ensureRegistered can wait until user registers
        let _registrationResolver = null;

        async function ensureRegistered() {
            const deviceId = getDeviceId();
            if (!deviceId) return; // cannot proceed without device id

            try {
                // Try Firestore first (if initialized)
                if (window._fb && window._fb.getDoc && window._fb.doc) {
                    try {
                        const resolved = await resolveUserDocRef(deviceId);
                        if (resolved && resolved.data) {
                            try { localStorage.setItem('gesCurrentUser', JSON.stringify(resolved.data)); } catch (e) { }
                            return; // already registered in Firestore (or migrated)
                        }
                    } catch (e) {
                        console.warn('Firestore check failed during registration:', e);
                        try { if (FIREBASE_NOTIFICATION_ENABLED) showMessage('Could not access Firebase during registration check — falling back to jsonbin.io', 'info'); } catch (err) { }
                        // fall through to jsonbin fallback
                    }
                }

                // Fallback to jsonbin check
                const data = await fetchJsonBinData();
                const users = Array.isArray(data) ? data : (data && data.users ? data.users : []);
                const found = users.find(u => u.deviceId === deviceId);
                if (found) {
                    // store current user locally for quick access
                    try { localStorage.setItem('gesCurrentUser', JSON.stringify(found)); } catch (e) { }
                    return; // already registered in jsonbin
                }
            } catch (e) {
                console.warn('Could not fetch jsonbin data during registration check:', e);
                // Allow registration flow even if fetch failed
            }

            // Not registered: hide loading overlay, render registration view and wait until registration completes
            const li = document.getElementById('loading-indicator');
            if (li) li.classList.add('hidden');
            // Disable nav to prevent tab switching until registration completes
            try { setNavDisabled(true); } catch (e) { }
            setView('register');
            return new Promise((resolve) => {
                _registrationResolver = resolve;
            });
        }

        function renderRegistrationView() {
            contentArea.innerHTML = `
                <div class="p-6 bg-white rounded-xl shadow-lg max-w-2xl mx-auto">
                    <h2 class="text-2xl font-bold mb-4">Register Your Device</h2>
                    <p class="text-sm text-gray-600 mb-4">Please provide your name, email and phone number to register this device. You must register before starting sessions.</p>
                    <div class="grid grid-cols-1 gap-3">
                        <input id="reg-name" placeholder="Full name" class="p-3 border rounded-lg" />
                        <input id="reg-email" placeholder="Email address" class="p-3 border rounded-lg" />
                        <input id="reg-phone" placeholder="Phone number" class="p-3 border rounded-lg" />
                        <div class="grid grid-cols-2 gap-3">
                            <input id="reg-city" placeholder="City (detected)" class="p-3 border rounded-lg" />
                            <input id="reg-country" placeholder="Country (detected)" class="p-3 border rounded-lg" />
                        </div>
                        <div class="flex gap-3 items-center">
                            <button onclick="submitRegistration()" class="px-4 py-2 bg-green-600 text-white rounded-lg">Register</button>
                            <button onclick="detectAndFillLocationInputs()" class="px-3 py-2 bg-gray-200 rounded-lg">Detect Location</button>
                        </div>
                        <p class="text-xs text-gray-500">Location is detected using your browser or IP and may be edited before submission.</p>
                    </div>
                </div>
            `;

            // Attempt to auto-detect location and prefill city/country inputs
            try { detectAndFillLocationInputs(); } catch (e) { console.debug('Auto-detect location failed:', e); }
        }

        async function submitRegistration() {
            const name = document.getElementById('reg-name').value.trim();
            const email = document.getElementById('reg-email').value.trim();
            const phone = document.getElementById('reg-phone').value.trim();
            const city = (document.getElementById('reg-city') && document.getElementById('reg-city').value.trim()) || null;
            const country = (document.getElementById('reg-country') && document.getElementById('reg-country').value.trim()) || null;
            if (!name || !email || !phone) { showMessage('Please fill all registration fields.', 'error'); return; }

            const deviceId = getDeviceId();
            const userObj = {
                name, email, phone,
                city: city || null,
                country: country || null,
                deviceId,
                createdAt: new Date().toISOString(),
                latestScore: null,
                lastTimestamp: null,
                scores: []
            };

            try {
                await registerUserToJsonBin(userObj);
                try { localStorage.setItem('gesCurrentUser', JSON.stringify(userObj)); } catch (e) { }
                showMessage('Registration successful.', 'success');
                if (_registrationResolver) {
                    _registrationResolver();
                    _registrationResolver = null;
                }
                // Re-enable navigation after successful registration
                try { setNavDisabled(false); } catch (e) { }
                setView('home');
            } catch (e) {
                console.error('Registration failed:', e);
                showMessage('Registration failed. See console for details.', 'error');
            }
        }

        async function registerUserToJsonBin(userObj) {
            // Prefer Firebase: write single user document to 'users' collection
            try {
                if (!firebaseInitialized) await initFirebase();
                if (firebaseInitialized && firestoreDb && window._fb && window._fb.setDoc) {
                    try {
                        // Prefer sanitized_name_deviceId id when available
                        const sanitizedName = sanitizeForDocId(userObj.name);

                        // STRICT REGISTRATION: Ensure we have a valid name to create the ID
                        if (sanitizedName && sanitizedName.length > 0 && userObj.deviceId) {
                            const preferredId = `${sanitizedName}_${userObj.deviceId}`;
                            const docRef = window._fb.doc(firestoreDb, 'users', preferredId);
                            // ensure deviceIds array exists for future lookups
                            userObj.deviceIds = Array.isArray(userObj.deviceIds) ? Array.from(new Set(userObj.deviceIds.concat([userObj.deviceId]))) : [userObj.deviceId];
                            await window._fb.setDoc(docRef, userObj);
                        } else {
                            // Abort if no valid name
                            console.warn('Registration aborted: Invalid or missing username for strict ID generation.');
                            showMessage('Registration failed: Invalid username.', 'error');
                            return;
                        }
                    } catch (e) {
                        console.debug('Registration write failed:', e);
                        showMessage('Could not save registration to cloud properly.', 'info');
                    }
                    try { setNavDisabled(false); } catch (e) { }
                    return;
                }
            } catch (e) {
                console.debug('Firebase registration write failed, falling back to jsonbin:', e);
                try { if (FIREBASE_NOTIFICATION_ENABLED) showMessage('Could not write registration to Firebase; saving to jsonbin.io instead.', 'info'); } catch (err) { }
            }

            // Fallback: read-modify-write the jsonbin
            let data = [];
            try {
                const fetched = await fetchJsonBinData();
                if (Array.isArray(fetched)) data = fetched;
                else if (fetched && Array.isArray(fetched.users)) data = fetched.users;
            } catch (e) {
                console.warn('Assuming empty jsonbin; will create new array.');
            }
            data.push(userObj);
            try {
                const payload = Array.isArray(data) ? data : { users: data };
                await putJsonBinData(payload);
                try { setNavDisabled(false); } catch (e) { }
                return;
            } catch (e) {
                throw e;
            }
        }

        async function updateUserScore(deviceId, percentage, timestamp, correctAnswers = null, totalQuestions = null) {
            // Prefer Firestore: update single user document
            // Do not create or update remote user records for unregistered devices
            if (!isUserRegistered()) {
                try { showMessage('Register to save your score and appear on the leaderboard.', 'info'); } catch (e) { }
                return;
            }
            try {
                if (!firebaseInitialized) await initFirebase();
                if (firebaseInitialized && firestoreDb && window._fb && window._fb.getDoc && window._fb.setDoc) {
                    // Resolve the appropriate user doc (handles migrated/sanitized ids)
                    const resolved = await resolveUserDocRef(deviceId);
                    let docRef = null;
                    let user = null;
                    if (resolved && resolved.ref) {
                        docRef = resolved.ref;
                        user = resolved.data || null;
                    }
                    // If no doc found, create a new one using current local user name if available
                    if (!docRef) {
                        let currentUser = null;
                        try { currentUser = JSON.parse(localStorage.getItem('gesCurrentUser') || 'null'); } catch (e) { currentUser = null; }

                        // STRICT WRITE: Must enforce name_deviceId format
                        const sanitized = (currentUser && currentUser.name) ? sanitizeForDocId(currentUser.name) : null;

                        // VALIDATION: Ensure sanitized name is not empty/null
                        if (sanitized && sanitized.length > 0 && deviceId) {
                            const strictId = `${sanitized}_${deviceId}`;
                            docRef = window._fb.doc(firestoreDb, 'users', strictId);
                        } else {
                            // Cannot write strict doc => abort (or prompt for registration/name)
                            console.warn("Save aborted: No valid username found to construct Strict ID. User must register.");
                            if (typeof showMessage === 'function') showMessage('Please register your name in "Settings" to save your scores.', 'error');
                            return;
                        }
                    }

                    const score = { percentage: parseFloat(percentage), timestamp, correctAnswers: correctAnswers, totalQuestions: totalQuestions };
                    if (user) {
                        user.scores = Array.isArray(user.scores) ? user.scores : [];
                        user.scores.push(score);
                        user.latestScore = parseFloat(percentage);
                        user.lastTimestamp = normalizeTimestampToISO(timestamp) || timestamp;
                        if (correctAnswers != null) user.latestCorrect = correctAnswers;
                        if (totalQuestions != null) user.latestTotal = totalQuestions;
                        user.deviceIds = Array.isArray(user.deviceIds) ? Array.from(new Set(user.deviceIds.concat([deviceId]))) : [deviceId];
                    } else {
                        let _loc = null;
                        try { _loc = JSON.parse(localStorage.getItem('gesDeviceLocation') || 'null'); } catch (e) { _loc = null; }
                        const city = _loc && _loc.city ? _loc.city : null;
                        const country = _loc && _loc.country ? _loc.country : null;
                        user = { deviceId, latestScore: parseFloat(percentage), lastTimestamp: normalizeTimestampToISO(timestamp) || timestamp, latestCorrect: correctAnswers, latestTotal: totalQuestions, city: city, country: country, scores: [{ percentage: parseFloat(percentage), timestamp, correctAnswers: correctAnswers, totalQuestions: totalQuestions }], deviceIds: [deviceId] };
                    }
                    await window._fb.setDoc(docRef, user).catch(() => null);
                    return;
                }
            } catch (e) {
                console.debug('Firestore user score update failed, falling back to jsonbin:', e);
                try { if (FIREBASE_NOTIFICATION_ENABLED) showMessage('Could not update score to Firebase; falling back to jsonbin.io', 'info'); } catch (err) { }
            }

            // Fallback: update jsonbin array
            try {
                const fetched = await fetchJsonBinData();
                let users = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.users) ? fetched.users : []);
                let changed = false;
                users = users.map(u => {
                    if (u.deviceId === deviceId) {
                        const score = { percentage: parseFloat(percentage), timestamp, correctAnswers: correctAnswers, totalQuestions: totalQuestions };
                        u.scores = Array.isArray(u.scores) ? u.scores : [];
                        u.scores.push(score);
                        u.latestScore = parseFloat(percentage);
                        u.lastTimestamp = timestamp;
                        if (correctAnswers != null) u.latestCorrect = correctAnswers;
                        if (totalQuestions != null) u.latestTotal = totalQuestions;
                        changed = true;
                    }
                    return u;
                });
                if (!changed) {
                    // If user not present, optionally create a minimal record
                    let _loc = null;
                    try { _loc = JSON.parse(localStorage.getItem('gesDeviceLocation') || 'null'); } catch (e) { _loc = null; }
                    const city = _loc && _loc.city ? _loc.city : null;
                    const country = _loc && _loc.country ? _loc.country : null;
                    users.push({ deviceId, latestScore: parseFloat(percentage), lastTimestamp: timestamp, latestCorrect: correctAnswers, latestTotal: totalQuestions, city: city, country: country, scores: [{ percentage: parseFloat(percentage), timestamp, correctAnswers: correctAnswers, totalQuestions: totalQuestions }] });
                }
                const payload = Array.isArray(fetched) ? users : { users };
                await putJsonBinData(payload);
                return;
            } catch (e) {
                console.error('Could not update user score on jsonbin (fallback failed):', e);
                throw e;
            }
        }

        // Silent update function for rankings table (prevents flash)
        function updateRankingsTable(users) {
            if (!users || users.length === 0) return;

            const tbody = document.getElementById('rankings-table-body');
            if (!tbody) return;

            // Use global filtering function to ensure consistent 5-day TTL
            const ranked = filterUsersForRankings(users);

            // Build rows with competition-style ranking
            let rowsArr = [];
            let prevScore = null;
            let prevTotal = null;
            let itemsBefore = 0;
            let currentRank = 1;
            for (let i = 0; i < ranked.length; i++) {
                const u = ranked[i];
                let rank;
                if (prevScore === u.latestScore && prevTotal === u.latestTotal) {
                    rank = currentRank;
                } else {
                    rank = itemsBefore + 1;
                    currentRank = rank;
                    prevScore = u.latestScore;
                    prevTotal = u.latestTotal;
                }
                itemsBefore++;
                rowsArr.push(`
                <tr class="border-b hover:bg-gray-50">
                    <td class="px-4 py-3 font-semibold">#${rank}</td>
                    <td class="px-4 py-3">${u.name}</td>
                    <td class="px-4 py-3 text-green-600 font-semibold">${u.latestCorrect}/${u.latestTotal}</td>
                    <td class="px-4 py-3 text-blue-600 font-bold">${u.latestScore}%</td>
                    <td class="px-4 py-3 text-sm text-gray-600">${u.timestamp ? new Date(u.timestamp).toLocaleString() : '—'}</td>
                </tr>
                `);
            }

            // Update without flash by setting innerHTML of tbody only
            tbody.innerHTML = rowsArr.join('');
        }

        async function renderRankingsView() {
            contentArea.innerHTML = `<div class="p-6 bg-white rounded-xl shadow-lg">Loading rankings...</div>`;
            try {
                // Prefer Firebase for fetching users; fallback to JSONBin
                let usersRaw = [];
                try {
                    if (!firebaseInitialized) await initFirebase();
                    if (firebaseInitialized && firestoreDb && window._fb && window._fb.getDocs) {
                        const qs = await window._fb.getDocs(window._fb.collection(firestoreDb, 'users'));
                        qs.forEach(d => {
                            // STRICT FILTER: Only include docs with "migrated" structure (name_deviceId)
                            // Heuristic: must have underscore AND have both name/deviceId fields
                            if (!d.id.includes('_')) return;

                            const u = d.data();
                            if (!u.name || !u.deviceId) return; // double check data integrity

                            usersRaw.push(u);
                            // Populate global cache for realtime updates (with merge)
                            if (u && u.deviceId) {
                                globalUsersCache[u.deviceId] = mergeUserStats(globalUsersCache[u.deviceId], u);
                            }
                        });
                    }
                } catch (e) {
                    console.debug('Could not fetch users from Firestore for online count (fallback to jsonbin):', e);
                    try { if (FIREBASE_NOTIFICATION_ENABLED) showMessage('Could not load leaderboard from Firebase; falling back to jsonbin.io', 'info'); } catch (err) { }
                }
                if (!usersRaw || usersRaw.length === 0) {
                    const fetched = await fetchJsonBinData();
                    usersRaw = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.users) ? fetched.users : []);
                }

                // Use global filtering function to ensure consistent 5-day TTL
                const ranked = filterUsersForRankings(usersRaw);

                if (!ranked || ranked.length === 0) {
                    contentArea.innerHTML = `<div class="p-6 bg-white rounded-xl shadow-lg text-center">No registered users found.</div>`;
                    return;
                }

                // Assign competition-style ranks (ties share same rank; next rank = position index+1)
                let rowsArr = [];
                let prevScore = null;
                let prevTotal = null;
                let itemsBefore = 0;
                let currentRank = 1;
                for (let i = 0; i < ranked.length; i++) {
                    const u = ranked[i];
                    let rank;
                    if (prevScore === u.latestScore && prevTotal === u.latestTotal) {
                        // same group as previous -> same rank
                        rank = currentRank;
                    } else {
                        rank = itemsBefore + 1;
                        currentRank = rank;
                        prevScore = u.latestScore;
                        prevTotal = u.latestTotal;
                    }
                    itemsBefore++;
                    rowsArr.push(`
                    <tr class="border-b hover:bg-gray-50">
                        <td class="px-4 py-3 font-semibold">#${rank}</td>
                        <td class="px-4 py-3">${u.name}</td>
                        <td class="px-4 py-3 text-green-600 font-semibold">${u.latestCorrect}/${u.latestTotal}</td>
                        <td class="px-4 py-3 text-blue-600 font-bold">${u.latestScore}%</td>
                        <td class="px-4 py-3 text-sm text-gray-600">${u.timestamp ? new Date(u.timestamp).toLocaleString() : '—'}</td>
                    </tr>
                `);
                }
                const rows = rowsArr.join('');

                contentArea.innerHTML = `
                    <div class="p-6 bg-white rounded-xl shadow-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-bold">Global Rankings</h2>
                            <div class="flex gap-2">
                                <button onclick="setView('leaderboard')" class="px-3 py-2 bg-gray-600 text-white rounded-lg">Back</button>
                            </div>
                        </div>
                        <div class="overflow-x-auto">
                            <table class="w-full border-collapse">
                                <thead class="bg-blue-600 text-white">
                                    <tr>
                                        <th class="px-4 py-2 text-left">Rank</th>
                                        <th class="px-4 py-2 text-left">Name</th>
                                        <th class="px-4 py-2 text-left">Score</th>
                                        <th class="px-4 py-2 text-left">Percentage</th>
                                        <th class="px-4 py-2 text-left">Date Obtained</th>
                                    </tr>
                                </thead>
                                <tbody id="rankings-table-body">
                                    ${rows}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            } catch (e) {
                console.error('Failed to render rankings:', e);
                contentArea.innerHTML = `<div class="p-6 bg-white rounded-xl shadow-lg text-red-600">Could not load rankings. See console for details.</div>`;
            }
        }

        // --- Online presence monitoring ---
        const HEARTBEAT_INTERVAL_MS = 30 * 1000; // 30s
        const ONLINE_WINDOW_MS = 2 * 60 * 1000; // 2 minutes
        let _heartbeatTimer = null;
        let _onlineFetchTimer = null;

        async function sendHeartbeatSilently() {
            try {
                const deviceId = getDeviceId();
                if (!deviceId) return;
                // Do not create or update remote user records for unregistered devices
                if (!isUserRegistered()) return;
                // Prefer updating a single user doc in Firestore
                const now = new Date().toISOString();
                try {
                    if (!firebaseInitialized) await initFirebase();
                    if (firebaseInitialized && firestoreDb && window._fb && window._fb.getDoc && window._fb.setDoc) {
                        const resolved = await resolveUserDocRef(deviceId);
                        let docRef = null;
                        let user = null;
                        if (resolved && resolved.ref) { docRef = resolved.ref; user = resolved.data || null; }
                        // If we found an existing user record, update lastTimestamp and optionally location
                        if (user && docRef) {
                            user.lastTimestamp = new Date().toISOString();
                            try {
                                const locStored = JSON.parse(localStorage.getItem('gesDeviceLocation') || 'null');
                                if (locStored && (locStored.city || locStored.country)) {
                                    if ((!user.city && locStored.city) || (!user.country && locStored.country) || (locStored.city && user.city !== locStored.city) || (locStored.country && user.country !== locStored.country)) {
                                        user.city = locStored.city || user.city;
                                        user.country = locStored.country || user.country;
                                    }
                                }
                            } catch (e) { /* silent */ }
                            await window._fb.setDoc(docRef, user).catch(() => null);
                        }
                        return;
                    }
                } catch (e) {
                    console.debug('Heartbeat update to Firestore failed, falling back to jsonbin:', e);
                }

                // Fallback: update jsonbin array record
                const fetched = await fetchJsonBinData();
                let users = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.users) ? fetched.users : []);
                let changed = false;
                users = users.map(u => {
                    if (u.deviceId === deviceId) {
                        u.lastTimestamp = now;
                        changed = true;
                    }
                    return u;
                });
                if (!changed) {
                    // Do not create a new jsonbin user for unregistered devices
                    // (only update existing records)
                } else {
                    try {
                        const locStored = JSON.parse(localStorage.getItem('gesDeviceLocation') || 'null');
                        if (locStored && (locStored.city || locStored.country)) {
                            users = users.map(u => {
                                if (u.deviceId === deviceId) {
                                    if ((!u.city && locStored.city) || (!u.country && locStored.country) || (locStored.city && u.city !== locStored.city) || (locStored.country && u.country !== locStored.country)) {
                                        u.city = locStored.city || u.city;
                                        u.country = locStored.country || u.country;
                                    }
                                }
                                return u;
                            });
                        }
                    } catch (e) { /* silent */ }
                }
                // Only persist updates back to jsonbin when we actually changed an existing user
                if (changed) {
                    const payload = Array.isArray(fetched) ? users : { users };
                    await putJsonBinData(payload);
                }
            } catch (e) {
                // silent: do not show errors to user
                console.debug('Heartbeat update failed (silent):', e);
            }
        }

        async function fetchOnlineCountAndRender() {
            try {
                // Prefer fetching from Firestore first
                let users = [];
                try {
                    if (!firebaseInitialized) await initFirebase();
                    if (firebaseInitialized && firestoreDb && window._fb && window._fb.getDocs) {
                        const qs = await window._fb.getDocs(window._fb.collection(firestoreDb, 'users'));
                        qs.forEach(d => users.push(d.data()));
                    }
                } catch (e) {
                    console.debug('Could not fetch users from Firestore for online count (fallback to jsonbin):', e);
                }
                if (!users || users.length === 0) {
                    const fetched = await fetchJsonBinData();
                    users = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.users) ? fetched.users : []);
                }
                const threshold = Date.now() - ONLINE_WINDOW_MS;
                const count = users.reduce((acc, u) => {
                    if (!u || !u.lastTimestamp) return acc;
                    const t = parseTimestampToMs(u.lastTimestamp);
                    if (!isNaN(t) && t >= threshold) return acc + 1;
                    return acc;
                }, 0);
                const el = document.getElementById('online-counter');
                if (el) el.textContent = `${count} user${count === 1 ? '' : 's'} online`;
                // Update persistent header badge
                const badge = document.getElementById('online-badge');
                if (badge) {
                    const color = count > 0 ? '#10B981' : '#9CA3AF';
                    const text = count > 0 ? `${count} online` : `— online`;
                    badge.innerHTML = `<svg class="w-4 h-4 mr-2" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg"><circle cx="4" cy="4" r="3" fill="${color}"/></svg><span class="font-extrabold text-lg" style="color: ${count > 0 ? '#065f46' : '#374151'}">${text}</span>`;
                    badge.classList.remove('bg-gray-100');
                    badge.classList.add(count > 0 ? 'bg-green-50' : 'bg-gray-100');
                }
            } catch (e) {
                console.debug('Failed to fetch online count (silent):', e);
                const el = document.getElementById('online-counter');
                if (el) el.textContent = `— users online`;
                const badge = document.getElementById('online-badge');
                if (badge) {
                    badge.innerHTML = `<svg class="w-4 h-4 mr-2" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg"><circle cx="4" cy="4" r="3" fill="#9CA3AF"/></svg><span class="font-extrabold text-lg" style="color:#374151">— online</span>`;
                    badge.classList.remove('bg-green-50');
                    badge.classList.add('bg-gray-100');
                }
            }
        }

        // Show a transient popup with current online usernames when the header badge is clicked
        async function showOnlineUsersPopup(ev) {
            try {
                // Toggle behavior: hide if already visible
                const existing = document.getElementById('online-users-popup');
                if (existing) { existing.remove(); document.removeEventListener('click', _onlinePopupOutsideClickHandler); document.removeEventListener('touchstart', _onlinePopupOutsideClickHandler); return; }

                // Fetch users (prefer Firestore, fallback to jsonbin)
                let users = [];
                try {
                    if (!firebaseInitialized) await initFirebase();
                    if (firebaseInitialized && firestoreDb && window._fb && window._fb.getDocs) {
                        const qs = await window._fb.getDocs(window._fb.collection(firestoreDb, 'users'));
                        qs.forEach(d => users.push(d.data()));
                    }
                } catch (e) {
                    console.debug('Could not fetch users from Firestore for online list (fallback to jsonbin):', e);
                }
                if (!users || users.length === 0) {
                    const fetched = await fetchJsonBinData().catch(() => null);
                    users = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.users) ? fetched.users : []);
                }

                const threshold = Date.now() - ONLINE_WINDOW_MS;
                const onlineUsers = users.filter(u => {
                    if (!u || !u.lastTimestamp) return false;
                    const t = parseTimestampToMs(u.lastTimestamp);
                    return !isNaN(t) && t >= threshold;
                }).filter(u => u && u.name).map(u => ({ name: u.name }));

                // Build popup element
                const popup = document.createElement('div');
                popup.id = 'online-users-popup';
                popup.className = 'bg-white rounded-lg shadow-lg border p-3 text-sm z-50';
                popup.style.position = 'absolute';
                popup.style.minWidth = '200px';
                popup.style.maxWidth = '360px';
                popup.style.boxSizing = 'border-box';

                if (onlineUsers.length === 0) {
                    popup.innerHTML = `<div class="font-semibold">No users currently online</div>`;
                } else {
                    const items = onlineUsers.map(u => `<div class="py-1">${escapeHtml(u.name)}</div>`).join('');
                    popup.innerHTML = `<div class="font-semibold mb-2">Users online</div><div>${items}</div>`;
                }

                document.body.appendChild(popup);

                // Position the popup under the badge
                const badge = document.getElementById('online-badge');
                if (badge) {
                    const rect = badge.getBoundingClientRect();
                    // prefer showing below the badge; if near viewport bottom, show above
                    const top = (rect.bottom + 8 + popup.offsetHeight) > window.innerHeight ? (rect.top - 8 - popup.offsetHeight) : (rect.bottom + 8);
                    const left = Math.max(8, Math.min(window.innerWidth - popup.offsetWidth - 8, rect.left));
                    popup.style.top = `${top + window.scrollY}px`;
                    popup.style.left = `${left + window.scrollX}px`;
                } else {
                    // default center-top
                    popup.style.top = `${50 + window.scrollY}px`;
                    popup.style.left = `${window.innerWidth / 2 - 180 + window.scrollX}px`;
                }

                // Hide when clicking/tapping outside (support touch devices)
                document.addEventListener('click', _onlinePopupOutsideClickHandler);
                document.addEventListener('touchstart', _onlinePopupOutsideClickHandler);
            } catch (e) {
                console.debug('Failed to show online users popup:', e);
            }
        }

        function _onlinePopupOutsideClickHandler(ev) {
            try {
                const popup = document.getElementById('online-users-popup');
                const badge = document.getElementById('online-badge');
                if (!popup) { document.removeEventListener('click', _onlinePopupOutsideClickHandler); return; }
                const target = ev.target;
                if (popup.contains(target) || (badge && badge.contains(target))) return; // click inside -> ignore
                popup.remove();
                document.removeEventListener('click', _onlinePopupOutsideClickHandler);
            } catch (e) { /* silent */ }
        }

        // --- Rankings auto-refresh ---
        let _rankingsRefreshTimer = null;
        function startRankingsAutoRefresh() {
            stopRankingsAutoRefresh();
            // Realtime listener now handles updates if setup
            if (firebaseInitialized && _realtimeUnsub) {
                // Just render once, the listener will handle subsequent updates
                try { if (currentView === 'rankings') renderRankingsView(true); } catch (e) { /* silent */ }
                return;
            }

            // Fallback polling if listener unavailable
            try { if (currentView === 'rankings') renderRankingsView(); } catch (e) { /* silent */ }
            _rankingsRefreshTimer = setInterval(() => {
                if (currentView === 'rankings') {
                    try { renderRankingsView(); } catch (e) { console.debug('Ranking refresh error:', e); }
                }
            }, HEARTBEAT_INTERVAL_MS);
        }

        function stopRankingsAutoRefresh() {
            if (_rankingsRefreshTimer) { clearInterval(_rankingsRefreshTimer); _rankingsRefreshTimer = null; }
        }

        // --- Update user location on jsonbin when a more precise location becomes available ---
        async function updateUserLocationIfBetter(loc) {
            try {
                if (!loc || (!loc.city && !loc.country)) return;
                const deviceId = getDeviceId();
                if (!deviceId) return;
                // Only modify remote records for registered users
                if (!isUserRegistered()) return;
                // Try Firestore update first
                try {
                    if (!firebaseInitialized) await initFirebase();
                    if (firebaseInitialized && firestoreDb && window._fb && window._fb.getDoc && window._fb.setDoc) {
                        const resolved = await resolveUserDocRef(deviceId);
                        if (!resolved || !resolved.ref || !resolved.data) return; // User not found in Firestore

                        const docRef = resolved.ref;
                        let user = resolved.data;
                        let changed = false;

                        if (user) {
                            if ((loc.city && (!user.city || user.city !== loc.city)) || (loc.country && (!user.country || user.country !== loc.country))) {
                                user.city = loc.city || user.city;
                                user.country = loc.country || user.country;
                                changed = true;
                            }
                            user.lastTimestamp = new Date().toISOString();
                        }
                        // Only update if there are changes (always update timestamp though?)
                        // Logic implies: if location changed OR we just want to update timestamp? 
                        // The original code only saved if 'changed && user'. 
                        // Let's stick to original logic: only save if location changed.
                        if (changed) {
                            await window._fb.setDoc(docRef, user);
                        }
                        return;
                    }
                } catch (e) {
                    console.debug('Could not update user location in Firestore (fallback to jsonbin):', e);
                }

                // Fallback: update jsonbin array
                const fetched = await fetchJsonBinData();
                let users = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.users) ? fetched.users : []);
                let changed = false;
                users = users.map(u => {
                    if (u.deviceId === deviceId) {
                        // Update only if we have better info
                        if ((loc.city && (!u.city || u.city !== loc.city)) || (loc.country && (!u.country || u.country !== loc.country))) {
                            u.city = loc.city || u.city;
                            u.country = loc.country || u.country;
                            changed = true;
                        }
                        // also refresh lastTimestamp
                        u.lastTimestamp = new Date().toISOString();
                    }
                    return u;
                });
                if (changed) {
                    const payload = Array.isArray(fetched) ? users : { users };
                    await putJsonBinData(payload);
                }
            } catch (e) {
                console.debug('Could not update user location on jsonbin (silent):', e);
            }
        }

        function startOnlineMonitoring() {
            // ensure we don't start multiple timers
            stopOnlineMonitoring();
            // Immediately update heartbeat (best-effort, silent)
            sendHeartbeatSilently();
            // Periodically send heartbeat
            _heartbeatTimer = setInterval(() => { sendHeartbeatSilently(); }, HEARTBEAT_INTERVAL_MS);
            // Periodically refresh online count UI
            fetchOnlineCountAndRender();
            _onlineFetchTimer = setInterval(() => { fetchOnlineCountAndRender(); }, HEARTBEAT_INTERVAL_MS);
            // Also send a heartbeat when the page becomes visible again
            document.addEventListener('visibilitychange', _visibilityHeartbeatHandler);
            // Try to send a final heartbeat when the page unloads (best-effort)
            window.addEventListener('beforeunload', _beforeUnloadHeartbeatHandler);
            // Attach click handler to header badge to show online users popup
            try {
                const badge = document.getElementById('online-badge');
                if (badge && !badge._onlineClickAttached) {
                    badge.addEventListener('click', showOnlineUsersPopup);
                    badge.addEventListener('touchstart', showOnlineUsersPopup);
                    badge._onlineClickAttached = true;
                }
            } catch (e) { /* silent */ }
        }

        let _realtimeUnsub = null;
        let _cachedOnlineUsers = []; // Cache for the listener data

        function startOnlineMonitoring() {
            // ensure we don't start multiple times
            stopOnlineMonitoring();
            // Immediately update heartbeat (best-effort, silent)
            sendHeartbeatSilently();
            // Periodically send heartbeat
            _heartbeatTimer = setInterval(() => { sendHeartbeatSilently(); }, HEARTBEAT_INTERVAL_MS);

            // Also send a heartbeat when the page becomes visible again
            document.addEventListener('visibilitychange', _visibilityHeartbeatHandler);
            // Try to send a final heartbeat when the page unloads (best-effort)
            window.addEventListener('beforeunload', _beforeUnloadHeartbeatHandler);

            // Start the single efficient Firestore listener
            if (firebaseInitialized) {
                setupRealtimeListener();
            } else {
                // Fallback for non-firebase (using old polling if absolutely necessary, or just wait for init)
                setTimeout(() => { if (firebaseInitialized) setupRealtimeListener(); }, 2000);
            }

            // Attach click handler to header badge to show online users popup
            try {
                const badge = document.getElementById('online-badge');
                if (badge && !badge._onlineClickAttached) {
                    badge.addEventListener('click', showOnlineUsersPopup);
                    badge.addEventListener('touchstart', showOnlineUsersPopup);
                    badge._onlineClickAttached = true;
                }
            } catch (e) { /* silent */ }
        }

        function setupRealtimeListener() {
            try {
                if (_realtimeUnsub) _realtimeUnsub(); // Clear existing

                // Efficient Query: Get the 50 most recently active users
                // This covers "Online Users" (recent timestamp) AND gives a good sample for the "Leaderboard"
                const q = window._fb.query(
                    window._fb.collection(firestoreDb, 'users'),
                    window._fb.orderBy('lastTimestamp', 'desc'),
                    window._fb.limit(50)
                );

                _realtimeUnsub = window._fb.onSnapshot(q, (snapshot) => {
                    const users = [];
                    snapshot.forEach(doc => {
                        // STRICT FILTER: Only update with "migrated" docs
                        if (!doc.id.includes('_')) return;

                        const u = doc.data();
                        if (!u || !u.name || !u.deviceId) return;

                        users.push(u);
                        // Update global cache with latest data (merged)
                        if (u && u.deviceId) {
                            globalUsersCache[u.deviceId] = mergeUserStats(globalUsersCache[u.deviceId], u);
                        }
                    });
                    _cachedOnlineUsers = users;

                    // 1. Update the "X users online" badge
                    updateOnlineCountUI(users);

                    // 2. Update Rankings Table using merged data
                    // We use the global cache which contains ALL users (from initial load) + latest updates
                    // This prevents the truncated list (50 users) from wiping out the full leaderboard
                    if (currentView === 'rankings') {
                        const existingTable = document.querySelector('#rankings-table-body');
                        if (!existingTable) {
                            renderRankingsView(true);
                        } else {
                            // Pass the full merged list to the update function
                            const cachedUsers = Object.values(globalUsersCache);
                            console.log(`[Rankings Debug] Listener update. Cache size: ${cachedUsers.length}. Incoming doc updates: ${users.length}`);
                            updateRankingsTable(cachedUsers);
                        }
                    }
                }, (error) => {
                    console.debug("Realtime listener error:", error);
                });

                console.log("Started efficient realtime Firestore listener");
            } catch (e) {
                console.warn("Failed to setup realtime listener:", e);
            }
        }

        function updateOnlineCountUI(users) {
            // Count how many are "online" (active in last 5 mins)
            const fiveMinsAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
            const onlineCount = users.filter(u => u.lastTimestamp > fiveMinsAgo).length;

            const badgeHtml = `<span id="online-badge" class="inline-flex items-center px-3 py-1 rounded-full text-lg font-extrabold text-gray-600 bg-gray-100 hover:bg-gray-200 cursor-pointer shadow-sm transition-all">
                    <svg class="w-4 h-4 mr-2 text-green-500 animate-pulse" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="4" cy="4" r="3" fill="currentColor" />
                    </svg>
                    ${onlineCount} online
                </span>`;

            // 1. Update the GLOBAL header badge (persistent)
            const headerBadgeContainer = document.getElementById('online-status-badge');
            if (headerBadgeContainer) {
                headerBadgeContainer.innerHTML = badgeHtml;
                // Re-attach listener
                const newBadge = document.getElementById('online-badge');
                if (newBadge) {
                    newBadge.addEventListener('click', showOnlineUsersPopup);
                    newBadge.addEventListener('touchstart', showOnlineUsersPopup);
                    newBadge._onlineClickAttached = true;
                }
            }

            // 2. Update the Home view badge (if visible)
            const homeCounter = document.getElementById('online-counter');
            if (homeCounter) {
                homeCounter.innerHTML = `<span class="inline-block px-3 py-1 bg-green-100 text-green-800 rounded-full text-sm font-bold shadow-sm animate-pulse cursor-pointer" onclick="showOnlineUsersPopup()">
                    <span class="w-2 h-2 inline-block bg-green-500 rounded-full mr-2"></span>
                    ${onlineCount} users online
                </span>`;
            }
        }

        function stopOnlineMonitoring() {
            if (_heartbeatTimer) { clearInterval(_heartbeatTimer); _heartbeatTimer = null; }
            if (_onlineFetchTimer) { clearInterval(_onlineFetchTimer); _onlineFetchTimer = null; } // Legacy cleanup
            if (_realtimeUnsub) {
                _realtimeUnsub();
                _realtimeUnsub = null;
                console.log("Stopped realtime listener");
            }

            try { document.removeEventListener('visibilitychange', _visibilityHeartbeatHandler); } catch (e) { }
            try { window.removeEventListener('beforeunload', _beforeUnloadHeartbeatHandler); } catch (e) { }
            try {
                const badge = document.getElementById('online-badge');
                if (badge && badge._onlineClickAttached) {
                    badge.removeEventListener('click', showOnlineUsersPopup);
                    try { badge.removeEventListener('touchstart', showOnlineUsersPopup); } catch (e) { }
                    delete badge._onlineClickAttached;
                }
                const popup = document.getElementById('online-users-popup'); if (popup) popup.remove();
                document.removeEventListener('click', _onlinePopupOutsideClickHandler);
            } catch (e) { /* silent */ }
        }

        function _visibilityHeartbeatHandler() {
            try {
                if (document.visibilityState === 'visible') sendHeartbeatSilently();
            } catch (e) { /* silent */ }
        }

        function _beforeUnloadHeartbeatHandler(e) {
            try {
                // Best-effort: use fetch with keepalive to attempt to send final timestamp
                const deviceId = getDeviceId();
                if (!deviceId) return;
                const now = new Date().toISOString();
                // Read-modify-write with keepalive may still be subject to browser limits; we do a minimal update
                (async () => {
                    try {
                        // Only send final heartbeat for registered users
                        if (!isUserRegistered()) return;
                        // Try Firestore quick-write first (best-effort)
                        try {
                            if (!firebaseInitialized) await initFirebase();
                            if (firebaseInitialized && firestoreDb && window._fb && window._fb.getDoc && window._fb.setDoc) {
                                const docRef = window._fb.doc(firestoreDb, 'users', deviceId);
                                const snap = await window._fb.getDoc(docRef).catch(() => null);
                                const exists = snap && (typeof snap.exists === 'function' ? snap.exists() : snap.exists);
                                let user = exists ? (snap.data ? snap.data() : (snap && snap.data) || {}) : null;
                                if (user) {
                                    user.lastTimestamp = now;
                                    await window._fb.setDoc(docRef, user);
                                    return; // done
                                } else {
                                    let _loc = null;
                                    try { _loc = JSON.parse(localStorage.getItem('gesDeviceLocation') || 'null'); } catch (e) { _loc = null; }
                                    const city = _loc && _loc.city ? _loc.city : null;
                                    const country = _loc && _loc.country ? _loc.country : null;
                                    user = { deviceId, latestScore: null, lastTimestamp: now, scores: [], city: city, country: country };
                                    await window._fb.setDoc(docRef, user);
                                    return; // done
                                }
                            }
                        } catch (e) {
                            console.debug('beforeunload: Firestore quick update failed, will fallback to jsonbin:', e);
                        }

                        // Fallback: update JSONBin via sendBeacon/PUT
                        const fetched = await fetchJsonBinData();
                        let users = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.users) ? fetched.users : []);
                        let found = false;
                        users = users.map(u => {
                            if (u.deviceId === deviceId) { u.lastTimestamp = now; found = true; }
                            return u;
                        });
                        if (!found) {
                            let _loc = null;
                            try { _loc = JSON.parse(localStorage.getItem('gesDeviceLocation') || 'null'); } catch (e) { _loc = null; }
                            const city = _loc && _loc.city ? _loc.city : null;
                            const country = _loc && _loc.country ? _loc.country : null;
                            users.push({ deviceId, latestScore: null, lastTimestamp: now, scores: [], city: city, country: country });
                        }
                        const payload = Array.isArray(fetched) ? users : { users };
                        // Attempt to send using fetch with keepalive
                        try {
                            navigator.sendBeacon && navigator.sendBeacon(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, JSON.stringify(payload));
                        } catch (err) {
                            try {
                                fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, { method: 'PUT', headers: { 'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_MASTER_KEY }, body: JSON.stringify(payload), keepalive: true });
                            } catch (e) { /* silent */ }
                        }
                    } catch (err) { /* silent */ }
                })();
            } catch (e) { /* silent */ }
        }

        function testVoice() {
            const synth = window.speechSynthesis;
            if (!synth) return;

            // Cancel any ongoing speech
            synth.cancel();

            const testText = "This is a test of the selected voice. You can now hear how the voice sounds.";
            const utterance = new SpeechSynthesisUtterance(testText);

            // Get the selected voice from the dropdown
            const selectedVoiceURI = document.getElementById('ttsVoice').value;
            if (selectedVoiceURI) {
                const selectedVoice = voices.find(v => v.voiceURI === selectedVoiceURI);
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }
            }

            // Use the rate and pitch from the sliders
            utterance.rate = parseFloat(document.getElementById('ttsRate').value);
            utterance.pitch = parseFloat(document.getElementById('ttsPitch').value);

            synth.speak(utterance);
        }


        // --- File Handling Logic (Remaining functions are unchanged) ---

        let selectedFiles = [];

        function handleFileSelection(event) {
            selectedFiles = Array.from(event.target.files);
            const fileListEl = document.getElementById('file-list');
            const processBtn = document.getElementById('process-files-btn');

            if (selectedFiles.length > 0) {
                fileListEl.innerHTML = selectedFiles.map(file => `<li><span class="font-semibold">${file.name}</span> (${(file.size / 1024).toFixed(1)} KB)</li>`).join('');
                fileListEl.classList.remove('italic');
                processBtn.disabled = false;
            } else {
                fileListEl.textContent = 'No files selected.';
                fileListEl.classList.add('italic');
                processBtn.disabled = true;
            }
        }

        async function confirmQuitQuiz() {
            const confirmed = await showCustomConfirm(
                "Quit Session?",
                "Are you sure you want to quit?<br><br>Your current progress will be <strong>lost</strong> and cannot be recovered.",
                "Yes, Quit",
                "No, Keep Playing",
                "bg-red-600 hover:bg-red-700"
            );

            if (confirmed) {
                resetAndStartNewSession();
            }
        }
        function isValidQuiz(data) {
            if (!Array.isArray(data) || data.length === 0) {
                return false;
            }
            // Basic validation check on the first question
            const firstQ = data[0];
            return firstQ.question && firstQ.options && firstQ.answer && firstQ.explanation &&
                typeof firstQ.question === 'string' && typeof firstQ.options === 'object' && typeof firstQ.answer === 'string';
        }

        async function processSelectedFiles() {
            if (selectedFiles.length === 0) {
                showMessage("Please select one or more JSON files first.", 'error');
                return;
            }

            const processBtn = document.getElementById('process-files-btn');
            processBtn.disabled = true;
            const originalText = processBtn.textContent;
            processBtn.textContent = 'Processing...';

            let combinedQuestions = [];
            let errors = 0;

            for (const file of selectedFiles) {
                try {
                    const content = await readFileAsText(file);
                    const fileData = JSON.parse(content);

                    if (!isValidQuiz(fileData)) {
                        errors++;
                        throw new Error(`Invalid structure in ${file.name}.`);
                    }

                    combinedQuestions = combinedQuestions.concat(fileData);

                } catch (error) {
                    showMessage(`Error loading ${file.name}: ${error.message}`, 'error');
                    console.error("File processing error:", error);
                    errors++;
                }
            }

            processBtn.textContent = originalText;
            selectedFiles = []; // Clear file list after processing
            document.getElementById('quizFileInput').value = null; // Clear file input
            document.getElementById('file-list').innerHTML = 'No files selected.';
            document.getElementById('file-list').classList.add('italic');

            if (combinedQuestions.length === 0) {
                showMessage(`No valid questions were loaded. ${errors} file(s) failed to load.`, 'error');
                renderManagementView();
                return;
            }

            // 4. Auto-reorganize and re-index IDs
            const finalQuestions = combinedQuestions.map((q, index) => ({
                ...q,
                id: index + 1 // Assign new sequential ID
            }));

            // 5. Save the new set
            saveQuestions(finalQuestions);

            // 6. Update settings based on max length
            quizSettings.numQuestions = Math.min(quizSettings.numQuestions, finalQuestions.length);
            saveSettings();

            showMessage(`Successfully combined and loaded ${finalQuestions.length} questions from ${selectedFiles.length - errors} file(s).`, 'success');
            renderManagementView(); // Rerender to show new question count
            setView('home'); // Go to home to start the quiz
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e.target.error);
                reader.readAsText(file);
            });
        }

        function downloadFile(content, fileName, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage(`Downloaded file: ${fileName}`, 'success');
        }

        function downloadTemplate() {
            const template = [
                {
                    "id": 1,
                    "question": "Example: What is the primary purpose of the GES Code of Conduct?",
                    "options": {
                        "A": "To mandate weekly staff meetings.",
                        "B": "To define ethical and professional standards for staff.",
                        "C": "To provide a list of all school infrastructure.",
                        "D": "To set the budget for the District Education Office."
                    },
                    "answer": "B",
                    "explanation": "The Code of Professional Conduct outlines the required behaviour, duties, and ethical standards for all personnel."
                },
                {
                    "id": 2,
                    "question": "Example: Which body issues the Teacher Professional Licence?",
                    "options": {
                        "A": "GES",
                        "B": "MoE",
                        "C": "NTC",
                        "D": "GNAT"
                    },
                    "answer": "C",
                    "explanation": "The National Teaching Council (NTC) is the statutory body responsible for licensing teachers."
                }
            ];
            downloadFile(JSON.stringify(template, null, 2), 'quiz_template.json', 'application/json');
        }

        function downloadQuiz() {
            if (allQuestions.length === 0) {
                showMessage("No quiz data to download.", 'error');
                return;
            }
            downloadFile(JSON.stringify(allQuestions, null, 2), `ges_promotion_quiz_${allQuestions.length}Qs.json`, 'application/json');
        }

        /**
         * Resets local storage and restores the default question set.
         */
        async function confirmReset() {
            const confirmed = await showCustomConfirm(
                "Reset Quiz Data?",
                "Are you sure you want to <strong>restore defaults</strong>?<br><br>This will <span class='text-red-500 font-bold'>delete</span> all your uploaded files and clear your current progress.",
                "Yes, Delete Everything",
                "No, Go Back",
                "bg-red-600 hover:bg-red-700"
            );

            if (confirmed) {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                userAnswers = {};
                loadState(); // This will reload from questions.json
                showMessage(`Quiz data has been reset from 'questions.json'.`, 'success');
            }
        }

        // --- Quiz Session Logic ---

        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        // Identify if a question is True/False (has exactly 2 options)
        function isTrueFalse(question) {
            if (!question || !question.options) return false;
            return Object.keys(question.options).length === 2;
        }

        // Get a sequential subset starting from a random index (with wraparound)
        function getSequentialRandomSubset(pool, count) {
            if (pool.length === 0) return [];
            if (pool.length <= count) return pool; // Not enough items, return all

            const startIndex = Math.floor(Math.random() * pool.length);
            const result = [];
            for (let i = 0; i < count; i++) {
                result.push(pool[(startIndex + i) % pool.length]);
            }
            return result;
        }

        function generateSessionQuestions() {
            // Segregate questions
            const tfQuestions = [];
            const mcQuestions = []; // Multiple choice (more than 2 options)

            allQuestions.forEach(q => {
                if (isTrueFalse(q)) {
                    tfQuestions.push(q);
                } else {
                    mcQuestions.push(q);
                }
            });

            // Calculate quotas
            // 33% (1/3) should be True/False
            const totalNeeded = quizSettings.numQuestions;
            let tfCount = Math.round(totalNeeded / 3);

            // If we don't have enough TF questions, take what we have
            if (tfCount > tfQuestions.length) {
                tfCount = tfQuestions.length;
            }

            let mcCount = totalNeeded - tfCount;
            // If we don't have enough MC questions, try to fill with TF if available
            if (mcCount > mcQuestions.length) {
                const shortfall = mcCount - mcQuestions.length;
                mcCount = mcQuestions.length;
                if (tfQuestions.length > tfCount) {
                    const extraTf = Math.min(shortfall, tfQuestions.length - tfCount);
                    tfCount += extraTf;
                }
            }

            let selectedMC = [];
            let selectedTF = [];

            if (quizSettings.randomize) {
                // Case 1: Fully Random
                const shuffledMC = shuffle([...mcQuestions]);
                const shuffledTF = shuffle([...tfQuestions]);
                selectedMC = shuffledMC.slice(0, mcCount);
                selectedTF = shuffledTF.slice(0, tfCount);
            } else {
                // Case 2: Sequential Random Start
                selectedMC = getSequentialRandomSubset(mcQuestions, mcCount);
                selectedTF = getSequentialRandomSubset(tfQuestions, tfCount);
            }

            // Combine: MC first, then TF at the end
            return [...selectedMC, ...selectedTF];
        }

        function startSession() {
            if (allQuestions.length === 0) {
                showMessage("Cannot start session. No questions loaded.", 'error');
                return;
            }

            window.speechSynthesis.cancel();

            // Use refined generation logic to pick session questions
            sessionQuestions = generateSessionQuestions();

            // Fallback/Safety: If generation failed to yield enough questions (e.g. strict filtering issue), 
            // utilize standard slice but this shouldn't happen with the logic above
            if (sessionQuestions.length === 0 && allQuestions.length > 0) {
                sessionQuestions = allQuestions.slice(0, quizSettings.numQuestions);
            }

            currentQuestionIndex = 0;
            userAnswers = {};
            currentSelection = null;
            feedbackShown = false;

            document.getElementById('quiz-pre-start').classList.add('hidden');
            document.getElementById('quiz-container').classList.remove('hidden');

            renderQuestion();
            showMessage(`New session started with ${sessionQuestions.length} questions.`, 'info');

            // Start timer if configured
            if (quizSettings.timeLimit > 0) {
                startTimer(quizSettings.timeLimit);
                document.getElementById('timer-container').classList.remove('hidden');
            } else {
                document.getElementById('timer-container').classList.add('hidden');
                document.getElementById('timer-bar').classList.remove('hidden'); // Show bar for score even if no timer
            }
        }

        // --- Timer Logic ---

        function startTimer(minutes) {
            stopTimer(); // Just in case

            const timerBar = document.getElementById('timer-bar');
            const timerDisplay = document.getElementById('timer-display');

            if (timerBar) timerBar.classList.remove('hidden');

            const now = Date.now();
            sessionEndTime = now + (minutes * 60 * 1000);

            updateTimerDisplay(); // Immediate update

            quizTimerInterval = setInterval(() => {
                const remaining = sessionEndTime - Date.now();
                if (remaining <= 0) {
                    stopTimer();
                    if (timerDisplay) timerDisplay.textContent = "00:00";
                    handleTimeUp();
                } else {
                    const m = Math.floor(remaining / 60000);
                    const s = Math.floor((remaining % 60000) / 1000);
                    if (timerDisplay) {
                        timerDisplay.textContent = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                        // Visual urgency warning
                        if (remaining < 60000) { // last minute
                            const timerContainer = document.getElementById('timer-container');
                            if (timerContainer) timerContainer.classList.add('animate-pulse', 'bg-red-200');
                        }
                    }
                }
            }, 1000);
        }

        function stopTimer() {
            if (quizTimerInterval) {
                clearInterval(quizTimerInterval);
                quizTimerInterval = null;
            }
            const timerBar = document.getElementById('timer-bar');
            const timerContainer = document.getElementById('timer-container');
            if (timerContainer) {
                timerContainer.classList.remove('animate-pulse', 'bg-red-200'); // remove urgency styles
            }
        }

        function updateTimerDisplay() {
            // Helper for manual updates if needed, though interval mostly handles it
            const display = document.getElementById('timer-display');
            if (!display || !sessionEndTime) return;
            const remaining = Math.max(0, sessionEndTime - Date.now());
            const m = Math.floor(remaining / 60000);
            const s = Math.floor((remaining % 60000) / 1000);
            display.textContent = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function handleTimeUp() {
            showMessage("Time's up! Session ended.", 'error');
            // Play a sound or TTS alert?
            if (quizSettings.ttsEnabled) {
                speak("Time is up. Submitting your quiz now.");
            }
            // Logic: End the quiz. Unanswered questions remain unanswered in `userAnswers`
            // and `calculateScore` will naturally count them as 0 correct.
            // We force a render of results.
            setTimeout(() => {
                renderResults();
            }, 1500); // Short delay to let the user see "00:00"
        }

        function renderQuestion() {
            const q = sessionQuestions[currentQuestionIndex];
            if (!q) {
                window.speechSynthesis.cancel();
                renderResults();
                return;
            }

            const userAnswer = userAnswers[q.id];
            currentSelection = userAnswer || null;
            feedbackShown = !!userAnswer;

            const questionArea = document.getElementById('question-area');
            const navigationArea = document.getElementById('navigation-area');
            const progressContainer = document.getElementById('progress-bar');
            const actionButtons = document.getElementById('action-buttons');
            const feedbackArea = document.getElementById('feedback-area');
            const totalQuestions = sessionQuestions.length;

            // Calculate current live score
            const currentScoreData = calculateScore();
            // Update Score in Timer Bar
            const scoreDisplay = document.getElementById('score-display');
            if (scoreDisplay) {
                scoreDisplay.textContent = `Score: ${currentScoreData.correct}/${totalQuestions}`;
            }

            let optionsHtml = '';
            for (const key in q.options) {
                let className = 'option-button';
                if (feedbackShown) {
                    if (key === q.answer) className += ' correct';
                    else if (key === userAnswer) className += ' incorrect';
                } else if (key === currentSelection) {
                    className += ' selected';
                }
                optionsHtml += `<button id="option-${key}" class="${className}" data-option="${key}" onclick="selectOption('${key}')" ${feedbackShown || reviewMode ? 'disabled' : ''}><span class="option-letter">${key}.</span><span class="text-left">${formatText(q.options[key])}</span></button>`;
            }

            questionArea.innerHTML = `
                <div class="mb-6 p-0">
                    <div class="flex flex-col sm:flex-row justify-between items-start text-gray-800">
                        <div class="flex-1 text-xl font-semibold p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500 shadow-inner">
                            <div class="mb-2 flex items-center flex-wrap">
                                <span class="text-blue-700 mr-2">Question ${currentQuestionIndex + 1} of ${totalQuestions}:</span>
                            </div>
                            <div class="prose">${formatText(q.question)}</div>
                        </div>        </div>
                                <div class="w-full sm:w-56 mt-3 sm:mt-0 sm:ml-4">
                                    <div class="bg-white p-3 rounded-lg border border-yellow-200 shadow-sm h-full flex flex-col justify-between">
                                        <div>
                                            <div class="text-sm font-semibold text-gray-700">Problem with this question?</div>
                                            <div class="text-xs text-gray-500 mt-1">Click the button below to flag typos, wrong answers, or ambiguous wording.</div>
                                        </div>
                                        <div class="mt-3">
                                            <button onclick="openReportDialog()" title="Report this question" class="w-full px-3 py-2 bg-yellow-500 text-white rounded-lg font-semibold hover:bg-yellow-600">Report Problem</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="options-container grid grid-cols-1 sm:grid-cols-2 gap-3">${optionsHtml}</div>
                    `;

            updateTtsButtons();
            renderActionButtons(actionButtons);
            renderNavigation(navigationArea);
            renderProgressBar(progressContainer);

            if (feedbackShown) {
                displayFeedback(q, userAnswer, feedbackArea, false);
            } else {
                feedbackArea.classList.add('hidden');
                feedbackArea.innerHTML = '';
                if (quizSettings.ttsEnabled && (currentQuestionIndex === 0 || userAnswer === null || shouldAutoSpeakQuestion)) {
                    let textToSpeak = `Question ${currentQuestionIndex + 1}. ${q.question}. Options: `;
                    textToSpeak += Object.entries(q.options).map(([key, value]) => `Option ${key}: ${value}.`).join(' ');
                    speak(textToSpeak);
                    shouldAutoSpeakQuestion = false; // Reset flag after speaking
                }
            }
        }

        function selectOption(optionKey) {
            if (feedbackShown) return;

            currentSelection = optionKey;

            document.querySelectorAll('.option-button').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.option === optionKey) {
                    btn.classList.add('selected');
                }
            });
            renderActionButtons(document.getElementById('action-buttons'));
        }

        async function confirmFinish() {
            // Check for unanswered questions
            const unanswered = [];
            for (let i = 0; i < sessionQuestions.length; i++) {
                if (!userAnswers[sessionQuestions[i].id]) {
                    unanswered.push(i);
                }
            }

            if (unanswered.length > 0) {
                const count = unanswered.length;
                // Interaction: User wants to know if they missed questions.
                // OK -> Go to question. Cancel -> Proceed to finish.

                // Use custom generic modal
                const shouldGoToQuestion = await showCustomConfirm(
                    "Unanswered Questions",
                    `You have <strong class="text-red-600">${count}</strong> unanswered question${count > 1 ? 's' : ''}.<br><br>For the best score, you should answer all questions.`,
                    "Review Unanswered",
                    "Submit Anyway",
                    "bg-blue-600 hover:bg-blue-700"
                );

                if (shouldGoToQuestion) {
                    goToQuestion(unanswered[0]);
                    return;
                }
            }
            renderResults();
        }

        function renderActionButtons(actionButtons) {
            actionButtons.innerHTML = '';
            const isLastQuestion = currentQuestionIndex === sessionQuestions.length - 1;
            const prevBtn = `<button onclick="navigate('prev')" ${currentQuestionIndex === 0 ? 'disabled' : ''} class="w-full sm:w-auto px-4 py-2 bg-gray-200 text-gray-700 font-bold rounded-lg hover:bg-gray-300 disabled:opacity-50">Previous</button>`;
            actionButtons.innerHTML += prevBtn;

            // Skip button (only if not answered yet)
            if (!feedbackShown) {
                const skipAction = isLastQuestion ? "confirmFinish()" : "navigate('next')";
                actionButtons.innerHTML += `<button onclick="${skipAction}" class="w-full sm:w-auto px-4 py-2 bg-yellow-100 text-yellow-800 font-bold rounded-lg hover:bg-yellow-200 border border-yellow-300 transition duration-150">Skip</button>`;
            }

            if (feedbackShown) {
                actionButtons.innerHTML += `<button onclick="navigate('next')" ${isLastQuestion ? 'disabled' : ''} class="w-full sm:w-auto px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 disabled:opacity-50">${isLastQuestion ? 'Review Complete' : 'Next'}</button>`;
            } else if (currentSelection) {
                actionButtons.innerHTML += `<button onclick="checkAnswer()" class="w-full sm:w-auto px-6 py-3 bg-green-600 text-white font-bold rounded-xl">Check Answer</button>`;
            } else {
                actionButtons.innerHTML += `<button disabled class="w-full sm:w-auto px-6 py-3 bg-gray-400 text-white font-bold rounded-xl">Select an Option</button>`;
            }

            if (isLastQuestion && feedbackShown) {
                actionButtons.innerHTML = `${prevBtn} <button onclick="confirmFinish()" class="w-full sm:w-auto px-6 py-3 bg-purple-600 text-white font-bold rounded-xl">View Score</button>`;
            }
        }

        // Updated displayFeedback signature to control TTS
        function displayFeedback(q, selectedOption, feedbackArea, useTts = true) {
            const isCorrect = selectedOption === q.answer;
            // Enhanced visual feedback colors as requested
            const statusClass = isCorrect
                ? 'bg-green-100 border-green-600 text-green-900 border-l-8'
                : 'bg-red-100 border-red-600 text-red-900 border-l-8';
            const statusText = isCorrect ? 'Correct!' : 'Incorrect.';

            feedbackArea.innerHTML = `
                <div class="p-6 rounded-lg ${statusClass} shadow-md transition-all duration-300">
                    <h4 class="font-extrabold text-2xl mb-2 flex items-center">
                        ${isCorrect ?
                    '<svg class="w-8 h-8 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' :
                    '<svg class="w-8 h-8 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>'}
                        ${statusText}
                    </h4>
                    <p class="text-lg">The correct answer is <span class="font-extrabold text-xl">${q.answer}</span>: ${formatText(q.options[q.answer])}</p>
                    <div class="mt-4 pt-4 border-t border-gray-300 border-opacity-30">
                        <p class="text-base font-medium"><b>Explanation:</b> ${formatText(q.explanation)}</p>
                    </div>
                </div>`;
            feedbackArea.classList.remove('hidden');

            if (useTts) {
                let feedbackText = `${statusText} ${q.explanation} so the correct answer is ${q.answer}: ${q.options[q.answer]}.`;
                speak(feedbackText);
            }
        }

        function renderReviewQuestion() {
            const q = sessionQuestions[currentQuestionIndex];
            if (!q) {
                returnToResults();
                return;
            }

            const userAnswer = userAnswers[q.id];
            const questionArea = document.getElementById('question-area-review');
            const navigationArea = document.getElementById('navigation-area-review');
            const progressContainer = document.getElementById('progress-bar-review');
            const actionButtons = document.getElementById('action-buttons-review');
            const feedbackArea = document.getElementById('feedback-area-review');
            const totalQuestions = sessionQuestions.length;

            let optionsHtml = '';
            for (const key in q.options) {
                let className = 'option-button';
                if (key === q.answer) className += ' correct';
                else if (key === userAnswer && userAnswer !== q.answer) className += ' incorrect';
                optionsHtml += `<button class="${className}" disabled><span class="option-letter">${key}.</span><span class="text-left">${formatText(q.options[key])}</span></button>`;
            }

            questionArea.innerHTML = `
                <div class="text-xl font-semibold text-gray-800 mb-6 p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500 shadow-inner">
                    <span class="text-blue-700 mr-2">Question ${currentQuestionIndex + 1} of ${totalQuestions}:</span>
                    ${formatText(q.question)}
                </div>
                <div class="options-container grid grid-cols-1 sm:grid-cols-2 gap-3">${optionsHtml}</div>
            `;

            // Show feedback with explanation
            displayFeedback(q, userAnswer, feedbackArea, false);

            renderReviewActionButtons(actionButtons);
            renderReviewNavigation(navigationArea);
            renderProgressBar(progressContainer);
        }

        function renderReviewActionButtons(actionButtons) {
            actionButtons.innerHTML = '';
            const prevBtn = `<button onclick="navigateReview('prev')" ${currentQuestionIndex === 0 ? 'disabled' : ''} class="w-full sm:w-auto px-4 py-2 bg-gray-200 text-gray-700 font-bold rounded-lg hover:bg-gray-300 disabled:opacity-50">Previous</button>`;
            actionButtons.innerHTML += prevBtn;

            const isLastQuestion = currentQuestionIndex === sessionQuestions.length - 1;
            if (isLastQuestion) {
                actionButtons.innerHTML += `<button onclick="returnToResults()" class="w-full sm:w-auto px-6 py-3 bg-purple-600 text-white font-bold rounded-xl">Review Complete</button>`;
            } else {
                actionButtons.innerHTML += `<button onclick="navigateReview('next')" class="w-full sm:w-auto px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">Next</button>`;
            }
        }

        function renderReviewNavigation(navigationArea) {
            navigationArea.innerHTML = `
                <div class="mt-8">
                    <h3 class="text-lg font-semibold mb-3 text-gray-700">Question Navigator</h3>
                    <div class="grid-container flex gap-2 p-2 bg-gray-100 rounded-lg">
                        ${sessionQuestions.map((q, index) => {
                const statusClass = userAnswers[q.id] ? 'nav-answered' : 'nav-unanswered';
                const isCurrent = index === currentQuestionIndex ? 'nav-current' : '';
                return `<button class="question-nav-button ${statusClass} ${isCurrent} flex-shrink-0" onclick="goToReviewQuestion(${index})">${index + 1}</button>`;
            }).join('')}
                    </div>
                </div>
            `;
        }

        function navigateReview(direction) {
            window.speechSynthesis.cancel();
            if (direction === 'next' && currentQuestionIndex < sessionQuestions.length - 1) {
                currentQuestionIndex++;
            } else if (direction === 'prev' && currentQuestionIndex > 0) {
                currentQuestionIndex--;
            }
            renderReviewQuestion();
        }

        function goToReviewQuestion(index) {
            window.speechSynthesis.cancel();
            currentQuestionIndex = index;
            renderReviewQuestion();
        }

        function checkAnswer() {
            if (!currentSelection) return;
            const q = sessionQuestions[currentQuestionIndex];
            userAnswers[q.id] = currentSelection;
            feedbackShown = true;
            renderQuestion();
            displayFeedback(q, currentSelection, document.getElementById('feedback-area'), true);
        }

        function navigate(direction) {
            window.speechSynthesis.cancel();
            if (direction === 'next' && currentQuestionIndex < sessionQuestions.length - 1) {
                currentQuestionIndex++;
                shouldAutoSpeakQuestion = true;
            } else if (direction === 'prev' && currentQuestionIndex > 0) {
                currentQuestionIndex--;
                shouldAutoSpeakQuestion = true;
            }
            renderQuestion();

            // Fix: Accurate scroll to top of the content area/question
            // Using a refined scroll logic to ensure the question start is visible
            setTimeout(() => {
                const titleArea = document.getElementById('quiz-title');
                // Scroll slightly above the title if possible, or top of page
                if (titleArea) {
                    titleArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } else {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }, 50);
        }

        function renderNavigation(navigationArea) {
            navigationArea.innerHTML = `
                <div class="mt-8">
                    <h3 class="text-lg font-semibold mb-3 text-gray-700">Question Navigator</h3>
                    <div class="grid-container flex gap-2 p-2 bg-gray-100 rounded-lg">
                        ${sessionQuestions.map((q, index) => {
                const statusClass = userAnswers[q.id] ? 'nav-answered' : 'nav-unanswered';
                const isCurrent = index === currentQuestionIndex ? 'nav-current' : '';
                return `<button class="question-nav-button ${statusClass} ${isCurrent} flex-shrink-0" id="nav-btn-${index}" onclick="goToQuestion(${index})">${index + 1}</button>`;
            }).join('')}
                    </div>
                </div>
            `;

            // Auto-scroll to the current question button
            setTimeout(() => {
                const currentButton = document.getElementById(`nav-btn-${currentQuestionIndex}`);
                if (currentButton) {
                    currentButton.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            }, 0);
        }

        function goToQuestion(index) {
            window.speechSynthesis.cancel();
            currentQuestionIndex = index;
            shouldAutoSpeakQuestion = true; // Set flag to auto-speak when jumping to question
            renderQuestion();
        }

        function calculateScore() {
            let correctCount = 0;
            sessionQuestions.forEach(q => {
                if (userAnswers[q.id] === q.answer) correctCount++;
            });
            return { correct: correctCount, total: sessionQuestions.length };
        }

        function saveSessionToHistory(correctAnswers, totalQuestions) {
            const percentage = ((correctAnswers / totalQuestions) * 100).toFixed(1);
            const session = {
                correctAnswers: correctAnswers,
                totalQuestions: totalQuestions,
                percentage: parseFloat(percentage),
                timestamp: new Date().toISOString()
            };
            sessionHistory.push(session);
            try {
                localStorage.setItem(SESSION_HISTORY_KEY, JSON.stringify(sessionHistory));
                console.log("Session saved to history:", session);
                // Also update the user's record in jsonbin (if registered)
                try {
                    const deviceId = getDeviceId();
                    if (deviceId) {
                        updateUserScore(deviceId, session.percentage, session.timestamp, session.correctAnswers, session.totalQuestions).catch(err => console.error('Failed to update user score:', err));
                    }
                } catch (e) {
                    console.warn('Could not update remote user score:', e);
                }
            } catch (e) {
                console.error("Error saving session to history:", e);
            }
        }

        function loadSessionHistory() {
            try {
                const saved = localStorage.getItem(SESSION_HISTORY_KEY);
                sessionHistory = saved ? JSON.parse(saved) : [];
                console.log(`Loaded ${sessionHistory.length} previous sessions from history`);
            } catch (e) {
                console.error("Error loading session history:", e);
                sessionHistory = [];
            }
        }

        function clearLeaderboard() {
            const confirmed = confirm("Are you sure you want to clear all session history? This action cannot be undone.");
            if (confirmed) {
                sessionHistory = [];
                try {
                    localStorage.removeItem(SESSION_HISTORY_KEY);
                    console.log("Session history cleared");
                    showMessage("Leaderboard has been cleared.", 'info');
                    renderLeaderboardView(); // Refresh the leaderboard view
                } catch (e) {
                    console.error("Error clearing session history:", e);
                    showMessage("Error clearing leaderboard data.", 'error');
                }
            }
        }

        function renderLeaderboardView() {
            const historyTableBody = sessionHistory.length === 0 ?
                '<tr><td colspan="5" class="px-6 py-4 text-center text-gray-500">No sessions yet. Complete a quiz to start tracking history.</td></tr>' :
                // Sort ascending by timestamp (oldest first)
                [...sessionHistory].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)).map((session, index) => {
                    const date = new Date(session.timestamp);
                    const formattedDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    const formattedTime = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                    return `
                        <tr class="border-b hover:bg-gray-100 transition text-sm sm:text-base">
                            <td class="px-2 sm:px-4 py-2 sm:py-4 font-semibold text-gray-700">#${index + 1}</td>
                            <td class="px-2 sm:px-4 py-2 sm:py-4 text-gray-600 hidden sm:table-cell">${session.totalQuestions}</td>
                            <td class="px-2 sm:px-4 py-2 sm:py-4 text-green-600 font-semibold">${session.correctAnswers}</td>
                            <td class="px-2 sm:px-4 py-2 sm:py-4 text-blue-600 font-bold">${session.percentage}%</td>
                            <td class="px-2 sm:px-4 py-2 sm:py-4 text-gray-500 text-xs sm:text-sm hidden md:table-cell">${formattedDate} at ${formattedTime}</td>
                        </tr>
                    `;
                }).join('');

            const avgScore = sessionHistory.length > 0 ?
                (sessionHistory.reduce((sum, s) => sum + s.percentage, 0) / sessionHistory.length).toFixed(1) : 0;
            const bestScore = sessionHistory.length > 0 ?
                Math.max(...sessionHistory.map(s => s.percentage)) : 0;
            const worstScore = sessionHistory.length > 0 ?
                Math.min(...sessionHistory.map(s => s.percentage)) : 0;

            const backButtonText = renderResultsCalled ? 'Back to Results' : 'Back to Home';

            contentArea.innerHTML = `
                <div class="p-4 sm:p-6 lg:p-8 bg-white rounded-xl shadow-lg">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-8">
                        <h2 class="text-2xl sm:text-3xl font-bold text-gray-800">Session History</h2>
                        <div class="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
                            <button onclick="clearLeaderboard()" class="px-4 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition flex-1 sm:flex-none">
                                Clear All
                            </button>
                            <button onclick="setView('rankings')" class="px-4 py-2 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition flex-1 sm:flex-none">
                                View Global Rankings
                            </button>
                            <button onclick="handleBackToHome()" class="px-4 py-2 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition flex-1 sm:flex-none">
                                ${backButtonText}
                            </button>
                        </div>
                    </div>

                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-3 sm:gap-4 mb-8">
                        <div class="bg-blue-50 border-l-4 border-blue-500 p-3 sm:p-4 rounded-lg">
                            <div class="text-xl sm:text-2xl font-bold text-blue-600">${sessionHistory.length}</div>
                            <div class="text-xs sm:text-sm text-gray-600">Total Sessions</div>
                        </div>
                        <div class="bg-green-50 border-l-4 border-green-500 p-3 sm:p-4 rounded-lg">
                            <div class="text-xl sm:text-2xl font-bold text-green-600">${avgScore}%</div>
                            <div class="text-xs sm:text-sm text-gray-600">Average Score</div>
                        </div>
                        <div class="bg-purple-50 border-l-4 border-purple-500 p-3 sm:p-4 rounded-lg">
                            <div class="text-xl sm:text-2xl font-bold text-purple-600">${bestScore}%</div>
                            <div class="text-xs sm:text-sm text-gray-600">Best Score</div>
                        </div>
                    </div>

                    <div class="mb-8 overflow-x-auto">
                        ${sessionHistory.length === 0 ?
                    `<div class="text-center py-8 text-gray-500">No sessions recorded yet. Complete a quiz to get started!</div>` :
                    `<table class="w-full border-collapse border border-gray-300 rounded-lg">
                            <thead class="bg-blue-600 text-white text-sm">
                                <tr>
                                    <th class="px-2 sm:px-4 py-2 sm:py-3 text-left">Session</th>
                                    <th class="px-2 sm:px-4 py-2 sm:py-3 text-left hidden sm:table-cell">Questions</th>
                                    <th class="px-2 sm:px-4 py-2 sm:py-3 text-left">Correct</th>
                                    <th class="px-2 sm:px-4 py-2 sm:py-3 text-left">Score</th>
                                    <th class="px-2 sm:px-4 py-2 sm:py-3 text-left hidden md:table-cell">Date & Time</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${historyTableBody}
                            </tbody>
                        </table>`
                }
                    </div>

                    ${sessionHistory.length > 0 ? `
                    <button onclick="setView('graph')" 
                        class="w-full px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition">
                        View Progress Graph
                    </button>
                ` : ``}
                </div>
            `;
        }

        function renderProgressGraphView() {
            if (sessionHistory.length === 0) {
                contentArea.innerHTML = `
                    <div class="p-8 text-center bg-yellow-50 rounded-lg border-2 border-yellow-300">
                        <h3 class="text-2xl font-bold text-yellow-800 mb-4">No Data to Display</h3>
                        <p class="text-gray-700 mb-6">Complete a quiz to see your progress graph.</p>
                        <button onclick="setView('leaderboard')" class="px-6 py-3 bg-yellow-600 text-white font-bold rounded-lg hover:bg-yellow-700 transition">
                            Back to Leaderboard
                        </button>
                    </div>
                `;
                return;
            }

            const stats = {
                avgScore: (sessionHistory.reduce((sum, s) => sum + s.percentage, 0) / sessionHistory.length).toFixed(1),
                bestScore: Math.max(...sessionHistory.map(s => s.percentage)),
                worstScore: Math.min(...sessionHistory.map(s => s.percentage)),
                totalSessions: sessionHistory.length,
                improvementTrend: sessionHistory.length > 1 ?
                    (sessionHistory[sessionHistory.length - 1].percentage - sessionHistory[0].percentage).toFixed(1) : 0
            };

            // Create SVG line graph
            const canvasWidth = 900;
            const canvasHeight = 400;
            const padding = 60;
            const plotWidth = canvasWidth - (padding * 2);
            const plotHeight = canvasHeight - (padding * 2);

            const maxScore = 100;
            const minScore = 0;
            const yRange = maxScore - minScore;

            let pathData = [];
            sessionHistory.forEach((session, index) => {
                const x = padding + (index / (sessionHistory.length - 1 || 1)) * plotWidth;
                const y = canvasHeight - padding - ((session.percentage - minScore) / yRange) * plotHeight;
                pathData.push(`${index === 0 ? 'M' : 'L'} ${x} ${y}`);
            });

            const svgLines = sessionHistory.map((session, index) => {
                const x = padding + (index / (sessionHistory.length - 1 || 1)) * plotWidth;
                const y = canvasHeight - padding - ((session.percentage - minScore) / yRange) * plotHeight;
                return `<circle cx="${x}" cy="${y}" r="5" fill="#3b82f6" stroke="white" stroke-width="2" class="hover:r-7 transition" title="${session.percentage}%"/>`;
            }).join('');

            contentArea.innerHTML = `
                <div class="p-8 bg-white rounded-xl shadow-lg">
                    <div class="flex justify-between items-center mb-8">
                        <h2 class="text-3xl font-bold text-gray-800">Performance Progress</h2>
                        <button onclick="goBack()" class="flex items-center px-4 py-2 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition"><svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>Back</button>
                    </div>

                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                        <div class="bg-blue-50 border-l-4 border-blue-500 p-4 rounded-lg">
                            <div class="text-2xl font-bold text-blue-600">${stats.avgScore}%</div>
                            <div class="text-sm text-gray-600">Average Score</div>
                        </div>
                        <div class="bg-green-50 border-l-4 border-green-500 p-4 rounded-lg">
                            <div class="text-2xl font-bold text-green-600">${stats.bestScore}%</div>
                            <div class="text-sm text-gray-600">Best Score</div>
                        </div>
                        <div class="bg-red-50 border-l-4 border-red-500 p-4 rounded-lg">
                            <div class="text-2xl font-bold text-red-600">${stats.worstScore}%</div>
                            <div class="text-sm text-gray-600">Worst Score</div>
                        </div>
                        <div class="bg-purple-50 border-l-4 border-purple-500 p-4 rounded-lg">
                            <div class="text-2xl font-bold ${stats.improvementTrend >= 0 ? 'text-purple-600' : 'text-red-600'}">${stats.improvementTrend >= 0 ? '+' : ''}${stats.improvementTrend}%</div>
                            <div class="text-sm text-gray-600">Overall Trend</div>
                        </div>
                    </div>

                    <div class="mb-8 bg-gray-50 p-6 rounded-lg border border-gray-200">
                        <h3 class="text-xl font-bold text-gray-800 mb-4">Score Progression Over Time</h3>
                        <svg width="100%" height="400" viewBox="0 0 900 400" style="background: white; border: 1px solid #e5e7eb; border-radius: 8px;">
                            <!-- Grid lines -->
                            <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${canvasHeight - padding}" stroke="#999" stroke-width="2"/>
                            <line x1="${padding}" y1="${canvasHeight - padding}" x2="${canvasWidth - padding}" y2="${canvasHeight - padding}" stroke="#999" stroke-width="2"/>
                            
                            <!-- Y-axis labels -->
                            <text x="${padding - 40}" y="${canvasHeight - padding + 5}" font-size="12" fill="#666">0%</text>
                            <text x="${padding - 40}" y="${padding + 5}" font-size="12" fill="#666">100%</text>
                            <text x="${padding - 40}" y="${Math.floor(canvasHeight - padding - plotHeight / 2) + 5}" font-size="12" fill="#666">50%</text>

                            <!-- Horizontal grid lines -->
                            <line x1="${padding}" y1="${canvasHeight - padding - plotHeight / 2}" x2="${canvasWidth - padding}" y2="${canvasHeight - padding - plotHeight / 2}" stroke="#ddd" stroke-width="1" stroke-dasharray="5,5"/>

                            <!-- Line path -->
                            <path d="${pathData.join(' ')}" stroke="#3b82f6" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"/>

                            <!-- Data points -->
                            ${svgLines}

                            <!-- X-axis labels -->
                            ${sessionHistory.map((session, index) => {
                const x = padding + (index / (sessionHistory.length - 1 || 1)) * plotWidth;
                return `<text x="${x}" y="${canvasHeight - padding + 20}" font-size="12" fill="#666" text-anchor="middle">#${index + 1}</text>`;
            }).join('')}
                        </svg>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <button onclick="setView('leaderboard')" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition">
                            Back to Leaderboard
                        </button>
                        <button onclick="setView('home')" class="px-6 py-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition">
                            Back to Home
                        </button>
                    </div>
                </div>
            `;
        }

        function handleBackToHome() {
            // If we came from results page, go back to results
            // Otherwise, go to home
            if (renderResultsCalled) {
                renderResults();
            } else {
                setView('home');
            }
        }

        function renderResults() {
            stopTimer();
            renderResultsCalled = true;
            window.speechSynthesis.cancel();
            const result = calculateScore();
            const percentage = ((result.correct / result.total) * 100).toFixed(1);

            // Generate performance appraisal
            let appraisal = '';
            if (percentage >= 90) {
                appraisal = `Excellent work! You scored ${percentage} percent, which is outstanding. You have demonstrated exceptional knowledge and mastery of the material.`;
            } else if (percentage >= 80) {
                appraisal = `Great job! You scored ${percentage} percent. You have a strong understanding of the material.`;
            } else if (percentage >= 70) {
                appraisal = `Good effort! You scored ${percentage} percent. You have a solid understanding of the material.`;
            } else if (percentage >= 60) {
                appraisal = `You scored ${percentage} percent. While you have a basic understanding, consider reviewing the material to improve your performance.`;
            } else {
                appraisal = `You scored ${percentage} percent. It is recommended that you review the material thoroughly and attempt the quiz again.`;
            }

            contentArea.innerHTML = `
                <div id="results-container" class="text-center p-8 bg-blue-50 rounded-xl">
                    <h2 class="text-4xl font-extrabold text-blue-700">Session Complete!</h2>
                    <div class="grid grid-cols-3 gap-4 text-white font-bold my-6">
                        <div class="bg-blue-600 p-4 rounded-lg"><div class="text-3xl">${result.total}</div><div>Total</div></div>
                        <div class="bg-green-600 p-4 rounded-lg"><div class="text-3xl">${result.correct}</div><div>Correct</div></div>
                        <div class="bg-red-600 p-4 rounded-lg"><div class="text-3xl">${percentage}%</div><div>Score</div></div>
                    </div>
                    <div class="my-6 p-4 bg-white rounded-lg border-l-4 border-blue-500">
                        <p class="text-gray-700 font-semibold">${appraisal}</p>
                    </div>
                    <div class="flex flex-col sm:flex-row justify-center gap-4 mt-8">
                        <button onclick="resetAndStartNewSession()" class="px-6 py-3 bg-purple-600 text-white font-bold rounded-lg hover:bg-purple-700">New Session</button>
                        <button onclick="startReview()" class="px-6 py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">Review Questions</button>
                        <button onclick="setView('leaderboard')" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700">View Leaderboard</button>
                    </div>
                </div>
                <div id="quiz-container-review" class="hidden">
                    <div class="flex justify-end gap-2 mb-4">
                        <button id="tts-toggle-btn-review" onclick="toggleTts()" class="flex items-center px-4 py-2 text-sm font-bold rounded-full transition duration-150 shadow-md"></button>
                        <button onclick="returnToResults()" class="flex items-center px-4 py-2 text-sm font-bold rounded-full bg-gray-500 text-white hover:bg-gray-600 transition duration-150 shadow-md"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>Back</button>
                    </div>
                    <div id="question-area-review"></div>
                    <div id="feedback-area-review" class="mt-6 hidden"></div>
                    <div id="action-buttons-review" class="mt-8 flex justify-between items-center flex-wrap gap-4"></div>
                    <div id="navigation-area-review" class="mt-8"></div>
                    <div id="progress-bar-review" class="mt-8"></div>
                </div>`;

            // Save session to history only once when quiz is completed
            if (!sessionResultsSaved && result.total > 0 && Object.keys(userAnswers).length === result.total) {
                saveSessionToHistory(result.correct, result.total);
                sessionResultsSaved = true;
            }

            // Speak the appraisal
            speak(appraisal);
        }

        function startReview() {
            reviewMode = true;
            currentQuestionIndex = 0;
            currentSelection = null;
            feedbackShown = false;
            // Show quiz review container
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('quiz-container-review').classList.remove('hidden');
            updateTtsButtons();
            renderReviewQuestion();
        }

        function returnToResults() {
            reviewMode = false;
            document.getElementById('quiz-container-review').classList.add('hidden');
            document.getElementById('results-container').classList.remove('hidden');
        }

        function resetAndStartNewSession() {
            // Reset all session state
            userAnswers = {};
            currentQuestionIndex = 0;
            currentSelection = null;
            feedbackShown = false;
            sessionQuestions = [];
            reviewMode = false;
            sessionResultsSaved = false; // Reset the save flag for new session
            renderResultsCalled = false; // Reset the results flag for new session
            // Go back to home view to show pre-start screen
            setView('home');
        }



        function renderProgressBar(progressContainer) {
            const answeredCount = Object.keys(userAnswers).length;
            const totalQuestions = sessionQuestions.length;
            const progressPercentage = totalQuestions > 0 ? ((answeredCount / totalQuestions) * 100) : 0;

            progressContainer.innerHTML = `
                <div class="flex justify-between mb-1 text-sm font-medium">
                    <span>Answered: ${answeredCount} / ${totalQuestions}</span>
                    <span>${progressPercentage.toFixed(0)}%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5"><div class="bg-blue-600 h-2.5 rounded-full" style="width: ${progressPercentage}%"></div></div>`;
        }

    </script>
    <!-- Admin / Reported Questions Logic (Restored) -->
    <script>
        // Admin UI logic for reported questions
        // Relies on global helpers: fetchAdminPasswordFromFirebase, loadReportsObject, updateReportStatus, deleteReport

        async function promptAdminAndShowReports() {
            try {
                showMessage("Verifying admin access...", "info");
                console.log("Starting admin authentication flow...");

                // 1. Fetch real password with timeout to prevent hanging  
                let realPassword = null;
                try {
                    // Create a timeout promise
                    const timeout = new Promise((resolve) => setTimeout(() => resolve("TIMEOUT"), 5000));
                    // Race the fetch against timeout
                    const result = await Promise.race([fetchAdminPasswordFromFirebase(), timeout]);

                    if (result === "TIMEOUT") {
                        console.warn("Admin password fetch timed out, using fallback");
                        realPassword = "admin";
                    } else {
                        realPassword = result;
                    }
                } catch (e) {
                    console.error("Error fetching admin password:", e);
                }

                if (!realPassword) realPassword = "admin"; // default fallback

                // Clear the "Verifying..." message by showing a new status or just proceeding
                // (prompt blocks execution, so message might persist until prompt is closed)

                const input = await showCustomPrompt(
                    "Admin Access Required",
                    "Please enter the administrative password to view reported questions.",
                    "Password",
                    "Access Reports",
                    "Cancel"
                );

                if (input === null) {
                    showMessage("Admin access cancelled.", "info");
                    return;
                }

                if (input !== realPassword) {
                    showMessage("Incorrect password.", "error");
                    return;
                }

                showMessage("Access granted. Loading reports...", "success");
                // Password correct, show reports
                renderReportsList();
            } catch (e) {
                console.error("promptAdminAndShowReports error:", e);
                showMessage("An error occurred: " + e.message, "error");
            }
        }

        async function renderReportsList() {
            const contentArea = document.getElementById('content-area');
            if (!contentArea) return;

            contentArea.innerHTML = `<div class="p-8 text-center"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div><p class="mt-4 text-gray-600">Loading reports...</p></div>`;

            try {
                const data = await loadReportsObject();
                // Ensure we get an array
                const reports = (data && data.reports && Array.isArray(data.reports)) ? data.reports : [];

                if (reports.length === 0) {
                    contentArea.innerHTML = `
                        <div class="p-6 bg-white rounded-xl shadow-lg">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-2xl font-bold text-gray-800">Reported Questions</h2>
                                <button onclick="renderSettingsView()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Back to Settings</button>
                            </div>
                            <div class="text-center py-12 bg-gray-50 rounded-lg border-2 border-dashed border-gray-200">
                                <p class="text-gray-500 text-lg">No reports found.</p>
                                <p class="text-sm text-gray-400 mt-2">Good job! The question bank seems clean.</p>
                            </div>
                        </div>`;
                    return;
                }

                // Sort by date desc (newest first)
                reports.sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0));

                const rows = reports.map(r => {
                    const qText = r.fullQuestionObject ? escapeHtml(r.fullQuestionObject.question) : "Unknown Question";
                    const tags = (r.tags || []).join(', ');
                    const statusColor = r.status === 'resolved' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';

                    return `
                        <tr class="border-b hover:bg-gray-50">
                            <td class="px-4 py-3 align-top">
                                <span class="inline-block px-2 py-1 rounded-full text-xs font-bold ${statusColor}">
                                    ${escapeHtml(r.status || 'open')}
                                </span>
                                <div class="text-xs text-gray-500 mt-1">${r.createdAt ? new Date(r.createdAt).toLocaleDateString() : '—'}</div>
                            </td>
                            <td class="px-4 py-3 align-top">
                                <div class="font-medium text-gray-900 mb-1">${qText}</div>
                                <div class="text-sm text-gray-600 italic">"${escapeHtml(r.comment || 'No comment')}"</div>
                                ${tags ? `<div class="mt-1 flex flex-wrap gap-1">${r.tags.map(t => `<span class="px-1.5 py-0.5 bg-gray-100 border rounded text-xs text-gray-600">${escapeHtml(t)}</span>`).join('')}</div>` : ''}
                            </td>
                            <td class="px-4 py-3 align-top text-right space-y-2">
                                ${r.status !== 'resolved' ?
                            `<button onclick="handleResolveReport('${r.id}')" class="w-full px-3 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700">Mark Resolved</button>` :
                            `<span class="text-xs text-gray-400">Resolved</span>`
                        }
                                <button onclick="handleDeleteReport('${r.id}')" class="w-full px-3 py-1 bg-red-100 text-red-700 text-xs rounded hover:bg-red-200">Delete</button>
                            </td>
                        </tr>
                    `;
                }).join('');

                contentArea.innerHTML = `
                    <div class="p-6 bg-white rounded-xl shadow-lg">
                        <div class="flex justify-between items-center mb-6">
                            <h2 class="text-2xl font-bold text-gray-800">Reported Questions (${reports.length})</h2>
                            <button onclick="renderSettingsView()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Back to Settings</button>
                        </div>
                        <div class="overflow-x-auto">
                            <table class="w-full text-left border-collapse">
                                <thead>
                                    <tr class="bg-gray-100 text-gray-600 text-sm uppercase tracking-wider">
                                        <th class="px-4 py-3 rounded-tl-lg">Status</th>
                                        <th class="px-4 py-3">Issue Detail</th>
                                        <th class="px-4 py-3 rounded-tr-lg text-right">Actions</th>
                                    </tr>
                                </thead>
                                <tbody class="text-sm">
                                    ${rows}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;

            } catch (e) {
                console.error('Error rendering reports:', e);
                showMessage("Failed to load reports.", "error");
            }
        }

        async function handleResolveReport(id) {
            if (!confirm("Mark this report as resolved?")) return;
            try {
                await updateReportStatus(id, 'resolved');
                renderReportsList(); // refresh
                showMessage("Report resolved.", "success");
            } catch (e) {
                showMessage("Failed to resolve.", "error");
            }
        }

        async function handleDeleteReport(id) {
            if (!confirm("Permanently delete this report?")) return;
            try {
                await deleteReport(id);
                renderReportsList(); // refresh
                showMessage("Report deleted.", "success");
            } catch (e) {
                showMessage("Failed to delete.", "error");
            }
        }
    </script>

    <script>
        // Start app
        window.onload = function () {
            loadState();
        };
    </script>
</body>

</html>

</html>